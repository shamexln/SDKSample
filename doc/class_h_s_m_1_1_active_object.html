<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Product Core System (PCS): HSM::ActiveObject Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Product Core System (PCS)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_h_s_m.html">HSM</a></li><li class="navelem"><a class="el" href="class_h_s_m_1_1_active_object.html">ActiveObject</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_h_s_m_1_1_active_object-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HSM::ActiveObject Class Reference<div class="ingroups"><a class="el" href="group___s32__group.html">S32</a> &raquo; <a class="el" href="group___h_s_m.html">HSM</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Runtime context (thread/process) of a set of event-handlers (e.g. state machines).  
 <a href="class_h_s_m_1_1_active_object.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_active_object_8h_source.html">Framework/HSM/Interface/ActiveObject.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for HSM::ActiveObject:</div>
<div class="dyncontent">
<div class="center"><img src="class_h_s_m_1_1_active_object__inherit__graph.png" border="0" usemap="#a_h_s_m_1_1_active_object_inherit__map" alt="Inheritance graph"/></div>
<map name="a_h_s_m_1_1_active_object_inherit__map" id="a_h_s_m_1_1_active_object_inherit__map">
<area shape="rect" title="Runtime context (thread/process) of a set of event&#45;handlers (e.g. state machines)." alt="" coords="225,439,387,663"/>
<area shape="rect" href="class_h_s_m_1_1_unit_test_1_1_mock_active_object.html" title=" " alt="" coords="215,711,397,1023"/>
<area shape="rect" href="class_h_s_m_1_1_active_object_base.html" title="Abstract base class for the ActiveObject class hierarchy." alt="" coords="5,79,191,317"/>
<area shape="rect" href="class_h_s_m_1_1_container_common.html" title="Base class for containers which aggregate multiple statemachines." alt="" coords="215,5,397,391"/>
<area shape="rect" href="class_h_s_m_1_1_abstract_input_queue.html" title="Abstract base class for an input queue delivering events to an active object from a different active ..." alt="" coords="421,130,596,266"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Name of this instance. For logging purposes only.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb7222268ad1247e1cdb1619f53f3e757"></a>Creates a runtime context whith an event-queue where event-handler (e.g. state-machines) can be registered at.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timerImpl</td><td>Provides a timer service which is capable of firing one-shot- aswell as periodic timer events. </td></tr>
    <tr><td class="paramname">debugImpl</td><td>Provides a logging object where data from the event-handlers is streamed into if the debug-flag for the corresponding event-handler is enabled.</td></tr>
    <tr><td class="paramname">queueSize</td><td>Size of the event-queue for all registred event-handlers in bytes. This size is fixed. If you get an "event-queue-overflow-exception" adjust the value accordingly. </td></tr>
    <tr><td class="paramname">internalQueueSize</td><td>Same as for queueSize but this size is used for the event-queue where only internal events are hold. Event-Handler can have internal-ports which can be used to retrigger the event-handler owning that internal-port. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr class="memitem:aa3cf876fa7a5aaea641615bdf9cb99b2"><td class="memItemLeft" align="right" valign="top"><a id="aa3cf876fa7a5aaea641615bdf9cb99b2"></a>
<a class="el" href="class_h_s_m_1_1_timer_impl.html">TimerImpl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#aa3cf876fa7a5aaea641615bdf9cb99b2">m_timerImpl</a></td></tr>
<tr class="memdesc:aa3cf876fa7a5aaea641615bdf9cb99b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:aa3cf876fa7a5aaea641615bdf9cb99b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6abe0e9580c2bf137b4a107ce48f17"><td class="memItemLeft" align="right" valign="top"><a id="a0f6abe0e9580c2bf137b4a107ce48f17"></a>
<a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a0f6abe0e9580c2bf137b4a107ce48f17">m_eventQueue</a></td></tr>
<tr class="memdesc:a0f6abe0e9580c2bf137b4a107ce48f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a0f6abe0e9580c2bf137b4a107ce48f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723eb51023363f25c68e70e3db05951d"><td class="memItemLeft" align="right" valign="top"><a id="a723eb51023363f25c68e70e3db05951d"></a>
<a class="el" href="class_h_s_m_1_1_debug_adapter_base.html">DebugAdapterBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a723eb51023363f25c68e70e3db05951d">m_debugAdapter</a></td></tr>
<tr class="memdesc:a723eb51023363f25c68e70e3db05951d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a723eb51023363f25c68e70e3db05951d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7ff54efdd74f8654062bc2b291aff9"><td class="memItemLeft" align="right" valign="top"><a id="afd7ff54efdd74f8654062bc2b291aff9"></a>
<a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#afd7ff54efdd74f8654062bc2b291aff9">m_internalQueue</a></td></tr>
<tr class="memdesc:afd7ff54efdd74f8654062bc2b291aff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:afd7ff54efdd74f8654062bc2b291aff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a9a3e625e53cd7050aa212d1e363b8"><td class="memItemLeft" align="right" valign="top"><a id="ad1a9a3e625e53cd7050aa212d1e363b8"></a>
<a class="el" href="class_h_s_m_1_1_event_ring_buffer_1_1iterator.html">EventRingBuffer::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#ad1a9a3e625e53cd7050aa212d1e363b8">m_eventQueueBegin</a></td></tr>
<tr class="memdesc:ad1a9a3e625e53cd7050aa212d1e363b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:ad1a9a3e625e53cd7050aa212d1e363b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb338f167ea5291c93fe29df3643ff23"><td class="memItemLeft" align="right" valign="top"><a id="aeb338f167ea5291c93fe29df3643ff23"></a>
<a class="el" href="class_h_s_m_1_1_event_ring_buffer_1_1iterator.html">EventRingBuffer::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#aeb338f167ea5291c93fe29df3643ff23">m_internalQueueBegin</a></td></tr>
<tr class="memdesc:aeb338f167ea5291c93fe29df3643ff23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:aeb338f167ea5291c93fe29df3643ff23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ce2aec89a82b728bae66902a547cb3"><td class="memItemLeft" align="right" valign="top"><a id="a13ce2aec89a82b728bae66902a547cb3"></a>
<a class="el" href="class_h_s_m_1_1_debuggable.html">Debuggable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a13ce2aec89a82b728bae66902a547cb3">m_defaultDebugOwner</a></td></tr>
<tr class="memdesc:a13ce2aec89a82b728bae66902a547cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a13ce2aec89a82b728bae66902a547cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8dded57902815fcf2184c6d76f1788"><td class="memItemLeft" align="right" valign="top"><a id="a1b8dded57902815fcf2184c6d76f1788"></a>
std::map&lt; std::string, <a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a1b8dded57902815fcf2184c6d76f1788">m_incomingQueues</a></td></tr>
<tr class="memdesc:a1b8dded57902815fcf2184c6d76f1788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a1b8dded57902815fcf2184c6d76f1788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5385a42f7b16a235be32946d53a23b9b"><td class="memItemLeft" align="right" valign="top"><a id="a5385a42f7b16a235be32946d53a23b9b"></a>
std::map&lt; std::string, <a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a5385a42f7b16a235be32946d53a23b9b">m_outgoingQueues</a></td></tr>
<tr class="memdesc:a5385a42f7b16a235be32946d53a23b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a5385a42f7b16a235be32946d53a23b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2775dea3f0a85ec780f943df2b2e97"><td class="memItemLeft" align="right" valign="top"><a id="abb2775dea3f0a85ec780f943df2b2e97"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#abb2775dea3f0a85ec780f943df2b2e97">m_hasExternalQueues</a> {}</td></tr>
<tr class="memdesc:abb2775dea3f0a85ec780f943df2b2e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:abb2775dea3f0a85ec780f943df2b2e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caa077fc083d92b4a087023d3a7178c"><td class="memItemLeft" align="right" valign="top"><a id="a6caa077fc083d92b4a087023d3a7178c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a6caa077fc083d92b4a087023d3a7178c">ActiveObject</a> (<a class="el" href="class_h_s_m_1_1_timer_impl.html">TimerImpl</a> &amp;timerImpl, <a class="el" href="class_h_s_m_1_1_debug_adapter_base.html">DebugAdapterBase</a> &amp;debugImpl, const std::string &amp;name, size_t queueSize=1000, size_t internalQueueSize=1000)</td></tr>
<tr class="memdesc:a6caa077fc083d92b4a087023d3a7178c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a6caa077fc083d92b4a087023d3a7178c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d15347e63ca729b3504f88dff996544"><td class="memItemLeft" align="right" valign="top"><a id="a8d15347e63ca729b3504f88dff996544"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a8d15347e63ca729b3504f88dff996544">ActiveObject</a> (const <a class="el" href="class_h_s_m_1_1_active_object.html">ActiveObject</a> &amp;right)=delete</td></tr>
<tr class="memdesc:a8d15347e63ca729b3504f88dff996544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a8d15347e63ca729b3504f88dff996544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f4a61d26c55520a49f81768f9ade42"><td class="memItemLeft" align="right" valign="top"><a id="a02f4a61d26c55520a49f81768f9ade42"></a>
<a class="el" href="class_h_s_m_1_1_active_object.html">ActiveObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a02f4a61d26c55520a49f81768f9ade42">operator=</a> (const <a class="el" href="class_h_s_m_1_1_active_object.html">ActiveObject</a> &amp;right)=delete</td></tr>
<tr class="memdesc:a02f4a61d26c55520a49f81768f9ade42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a02f4a61d26c55520a49f81768f9ade42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80273c8983048331c707e2477f709989"><td class="memItemLeft" align="right" valign="top"><a id="a80273c8983048331c707e2477f709989"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a80273c8983048331c707e2477f709989">~ActiveObject</a> () override</td></tr>
<tr class="memdesc:a80273c8983048331c707e2477f709989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a80273c8983048331c707e2477f709989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bed0be99f76ec52a3d473497c405de1"><td class="memItemLeft" align="right" valign="top"><a id="a4bed0be99f76ec52a3d473497c405de1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a4bed0be99f76ec52a3d473497c405de1">init</a> () override</td></tr>
<tr class="memdesc:a4bed0be99f76ec52a3d473497c405de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a4bed0be99f76ec52a3d473497c405de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884e364502f237824e7948088876da03"><td class="memItemLeft" align="right" valign="top"><a id="a884e364502f237824e7948088876da03"></a>
<a class="el" href="class_h_s_m_1_1_debug_adapter_base.html">DebugAdapterBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a884e364502f237824e7948088876da03">getDebugAdapter</a> () const override</td></tr>
<tr class="memdesc:a884e364502f237824e7948088876da03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a884e364502f237824e7948088876da03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96652ac4de9d460d53a7dfc3d801910a"><td class="memItemLeft" align="right" valign="top"><a id="a96652ac4de9d460d53a7dfc3d801910a"></a>
const <a class="el" href="class_h_s_m_1_1_debuggable.html">Debuggable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a96652ac4de9d460d53a7dfc3d801910a">getDefaultDebugOwner</a> () const override</td></tr>
<tr class="memdesc:a96652ac4de9d460d53a7dfc3d801910a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a96652ac4de9d460d53a7dfc3d801910a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991e159a48dea3448f6966f3c087dbe1"><td class="memItemLeft" align="right" valign="top"><a id="a991e159a48dea3448f6966f3c087dbe1"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a991e159a48dea3448f6966f3c087dbe1">getName</a> () const override</td></tr>
<tr class="memdesc:a991e159a48dea3448f6966f3c087dbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this active object, same as given to ctor. <br /></td></tr>
<tr class="separator:a991e159a48dea3448f6966f3c087dbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8699f4fadfa4aee18153146e9e2fd466"><td class="memItemLeft" align="right" valign="top"><a id="a8699f4fadfa4aee18153146e9e2fd466"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a8699f4fadfa4aee18153146e9e2fd466">getFullName</a> () const override</td></tr>
<tr class="memdesc:a8699f4fadfa4aee18153146e9e2fd466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this active object, same as given to ctor. <br /></td></tr>
<tr class="separator:a8699f4fadfa4aee18153146e9e2fd466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27fffb756d56f233e6d247c7c5e5e3b"><td class="memItemLeft" align="right" valign="top"><a id="af27fffb756d56f233e6d247c7c5e5e3b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#af27fffb756d56f233e6d247c7c5e5e3b">makeQueueFrom</a> (<a class="el" href="class_h_s_m_1_1_active_object_base.html">ActiveObjectBase</a> &amp;otherActiveObject, size_t size=1000)</td></tr>
<tr class="memdesc:af27fffb756d56f233e6d247c7c5e5e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the infrastructure for thread-crossing connections of ports from one to another active object. Only one queue is needed for many connections from one thread to another. This method is typically called from a different thread and should typically be called in the start up phase of the thread before making any thread crossing connections. When called twice with different size arguments, the second size is ignored. <br /></td></tr>
<tr class="separator:af27fffb756d56f233e6d247c7c5e5e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e92d44b392f234bf9c62606ad6da09"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#ae9e92d44b392f234bf9c62606ad6da09">makeQueueFrom</a> (const std::string &amp;otherThreadName, size_t size=1000)</td></tr>
<tr class="memdesc:ae9e92d44b392f234bf9c62606ad6da09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same semantics as <a class="el" href="class_h_s_m_1_1_active_object.html#af27fffb756d56f233e6d247c7c5e5e3b">HSM::ActiveObject::makeQueueFrom</a>, but this method is necessary to create a queue to be used by ports that are not running on ActiveObjects.  <a href="class_h_s_m_1_1_active_object.html#ae9e92d44b392f234bf9c62606ad6da09">More...</a><br /></td></tr>
<tr class="separator:ae9e92d44b392f234bf9c62606ad6da09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a55a3dabb13dc251bc9da770071e1d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a3a55a3dabb13dc251bc9da770071e1d7">runSingleLoop</a> ()</td></tr>
<tr class="memdesc:a3a55a3dabb13dc251bc9da770071e1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches one event from the event queue to its corresponding event handler.  <a href="class_h_s_m_1_1_active_object.html#a3a55a3dabb13dc251bc9da770071e1d7">More...</a><br /></td></tr>
<tr class="separator:a3a55a3dabb13dc251bc9da770071e1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add97ff4b7d01fd6f5c6227228cbb19f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#add97ff4b7d01fd6f5c6227228cbb19f6">runOnce</a> ()</td></tr>
<tr class="memdesc:add97ff4b7d01fd6f5c6227228cbb19f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches all events from the event queue to their corresponding event handlers until the event queue is empty.  <a href="class_h_s_m_1_1_active_object.html#add97ff4b7d01fd6f5c6227228cbb19f6">More...</a><br /></td></tr>
<tr class="separator:add97ff4b7d01fd6f5c6227228cbb19f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2125ef64fbc81b47eba061238c1a7dca"><td class="memItemLeft" align="right" valign="top"><a id="a2125ef64fbc81b47eba061238c1a7dca"></a>
<a class="el" href="class_h_s_m_1_1_timer_impl.html">TimerImpl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a2125ef64fbc81b47eba061238c1a7dca">getTimerImpl</a> () const override</td></tr>
<tr class="memdesc:a2125ef64fbc81b47eba061238c1a7dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the timer service object, same as given to ctor. <br /></td></tr>
<tr class="separator:a2125ef64fbc81b47eba061238c1a7dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d60bdccc496a87bddf8fe25d7a35858"><td class="memItemLeft" align="right" valign="top"><a id="a9d60bdccc496a87bddf8fe25d7a35858"></a>
<a class="el" href="class_h_s_m_1_1_active_object_base.html">ActiveObjectBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a9d60bdccc496a87bddf8fe25d7a35858">getActiveObject</a> () const override</td></tr>
<tr class="memdesc:a9d60bdccc496a87bddf8fe25d7a35858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns itself. <br /></td></tr>
<tr class="separator:a9d60bdccc496a87bddf8fe25d7a35858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12cbb6fddc57891dcfa1c9e379d3697"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#ac12cbb6fddc57891dcfa1c9e379d3697">cancelEvent</a> (unsigned short signal, const <a class="el" href="class_h_s_m_1_1_local_in_port.html">LocalInPort</a> &amp;port) override</td></tr>
<tr class="memdesc:ac12cbb6fddc57891dcfa1c9e379d3697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks event within the event queue from given port with given signal as canceled.  <a href="class_h_s_m_1_1_active_object.html#ac12cbb6fddc57891dcfa1c9e379d3697">More...</a><br /></td></tr>
<tr class="separator:ac12cbb6fddc57891dcfa1c9e379d3697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8f3923051d2271303e6de9112c3667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a5b8f3923051d2271303e6de9112c3667">cancelEvents</a> (<a class="el" href="class_h_s_m_1_1_local_in_port.html">LocalInPort</a> &amp;localInPort) override</td></tr>
<tr class="memdesc:a5b8f3923051d2271303e6de9112c3667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks all events within the event queue which are to be dispatched to the given port as canceled.  <a href="class_h_s_m_1_1_active_object.html#a5b8f3923051d2271303e6de9112c3667">More...</a><br /></td></tr>
<tr class="separator:a5b8f3923051d2271303e6de9112c3667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa592f6ec0d42b68f336ecb2c5884b3d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#aa592f6ec0d42b68f336ecb2c5884b3d5">cancelEvents</a> (<a class="el" href="class_h_s_m_1_1_state_machine_base.html">StateMachineBase</a> &amp;stateMachine) const override</td></tr>
<tr class="memdesc:aa592f6ec0d42b68f336ecb2c5884b3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks all events within the event queue which are to be dispatched to the given event handler as canceled.  <a href="class_h_s_m_1_1_active_object.html#aa592f6ec0d42b68f336ecb2c5884b3d5">More...</a><br /></td></tr>
<tr class="separator:aa592f6ec0d42b68f336ecb2c5884b3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac3140297357c7371e7d409988a35a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a5ac3140297357c7371e7d409988a35a2">post</a> (const <a class="el" href="class_h_s_m_1_1_event_impl.html">EventImpl</a> &amp;evt, const <a class="el" href="class_h_s_m_1_1_local_in_port.html">LocalInPort</a> &amp;port, unsigned short portInstance) override</td></tr>
<tr class="memdesc:a5ac3140297357c7371e7d409988a35a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the given event received by given port on given port instance into the event queue.  <a href="class_h_s_m_1_1_active_object.html#a5ac3140297357c7371e7d409988a35a2">More...</a><br /></td></tr>
<tr class="separator:a5ac3140297357c7371e7d409988a35a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e1475f65a571c1d59b576c3ff52faa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a63e1475f65a571c1d59b576c3ff52faa">postInternal</a> (const <a class="el" href="class_h_s_m_1_1_event_impl.html">EventImpl</a> &amp;evt, const <a class="el" href="class_h_s_m_1_1_local_in_port.html">LocalInPort</a> &amp;port, unsigned short portInstance) override</td></tr>
<tr class="memdesc:a63e1475f65a571c1d59b576c3ff52faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the given event received by given port on given port instance into the internal event queue.  <a href="class_h_s_m_1_1_active_object.html#a63e1475f65a571c1d59b576c3ff52faa">More...</a><br /></td></tr>
<tr class="separator:a63e1475f65a571c1d59b576c3ff52faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c14b3d0a064b52665725c865f35879a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a8c14b3d0a064b52665725c865f35879a">setWriterTaskId</a> () override</td></tr>
<tr class="separator:a8c14b3d0a064b52665725c865f35879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30389b9634cd0d29ac8c3f6ad0b16013"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a30389b9634cd0d29ac8c3f6ad0b16013">unsetWriterTaskId</a> () override</td></tr>
<tr class="separator:a30389b9634cd0d29ac8c3f6ad0b16013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd7a92b27b8849ccf485ec21fb0bd39"><td class="memItemLeft" align="right" valign="top"><a id="a4dd7a92b27b8849ccf485ec21fb0bd39"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a4dd7a92b27b8849ccf485ec21fb0bd39">dumpEventQueue</a> () const</td></tr>
<tr class="memdesc:a4dd7a92b27b8849ccf485ec21fb0bd39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps content of event queue into log. <br /></td></tr>
<tr class="separator:a4dd7a92b27b8849ccf485ec21fb0bd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae236506cd846ba8087764d3ec0218d7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#ae236506cd846ba8087764d3ec0218d7d">getQueueFrom</a> (std::string otherThreadName) override</td></tr>
<tr class="memdesc:ae236506cd846ba8087764d3ec0218d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If two active-objects are connected one needs to be able to put events into the event queue of the otherone, this can be done with this method.  <a href="class_h_s_m_1_1_active_object.html#ae236506cd846ba8087764d3ec0218d7d">More...</a><br /></td></tr>
<tr class="separator:ae236506cd846ba8087764d3ec0218d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5889e61a680dc1d50118b7c7dfad749"><td class="memItemLeft" align="right" valign="top"><a id="ae5889e61a680dc1d50118b7c7dfad749"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#ae5889e61a680dc1d50118b7c7dfad749">getThreadName</a> () const override</td></tr>
<tr class="memdesc:ae5889e61a680dc1d50118b7c7dfad749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a thread id. <br /></td></tr>
<tr class="separator:ae5889e61a680dc1d50118b7c7dfad749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631b5a1e5f1fd15284eadf26d18fdb2c"><td class="memItemLeft" align="right" valign="top"><a id="a631b5a1e5f1fd15284eadf26d18fdb2c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a631b5a1e5f1fd15284eadf26d18fdb2c">getEventQueueSize</a> () const</td></tr>
<tr class="memdesc:a631b5a1e5f1fd15284eadf26d18fdb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of event queue in bytes. <br /></td></tr>
<tr class="separator:a631b5a1e5f1fd15284eadf26d18fdb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f590ba33054df1e8425eaf5b0f360f"><td class="memItemLeft" align="right" valign="top"><a id="af1f590ba33054df1e8425eaf5b0f360f"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#af1f590ba33054df1e8425eaf5b0f360f">getInternalEventQueueSize</a> () const</td></tr>
<tr class="memdesc:af1f590ba33054df1e8425eaf5b0f360f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of internal event queue in bytes. <br /></td></tr>
<tr class="separator:af1f590ba33054df1e8425eaf5b0f360f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bcdfad3b0d97a1d7d21784cf5ec1b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a93bcdfad3b0d97a1d7d21784cf5ec1b6">logMaxFillLevels</a> () const</td></tr>
<tr class="separator:a93bcdfad3b0d97a1d7d21784cf5ec1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae267ff403d915c6864bfd48f5311bcb0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#ae267ff403d915c6864bfd48f5311bcb0">processInputQueueSingle</a> ()</td></tr>
<tr class="memdesc:ae267ff403d915c6864bfd48f5311bcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes one event from an event queue which is connected to another active object.  <a href="class_h_s_m_1_1_active_object.html#ae267ff403d915c6864bfd48f5311bcb0">More...</a><br /></td></tr>
<tr class="separator:ae267ff403d915c6864bfd48f5311bcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8423628952b443a3cb984e2b76c06ab8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a8423628952b443a3cb984e2b76c06ab8">processInputQueue</a> () override</td></tr>
<tr class="memdesc:a8423628952b443a3cb984e2b76c06ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes all events from an event queue which is connected to another active object.  <a href="class_h_s_m_1_1_active_object.html#a8423628952b443a3cb984e2b76c06ab8">More...</a><br /></td></tr>
<tr class="separator:a8423628952b443a3cb984e2b76c06ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5dd93670faee4749900a34c074cb78"><td class="memItemLeft" align="right" valign="top"><a id="aee5dd93670faee4749900a34c074cb78"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#aee5dd93670faee4749900a34c074cb78">addQueueTo</a> (const std::string &amp;otherThreadName, <a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a> *queue) override</td></tr>
<tr class="memdesc:aee5dd93670faee4749900a34c074cb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">add tracking of an thread crossing queue to another object <br /></td></tr>
<tr class="separator:aee5dd93670faee4749900a34c074cb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb9781520fb131d84adbf559d72ff74"><td class="memItemLeft" align="right" valign="top"><a id="aadb9781520fb131d84adbf559d72ff74"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#aadb9781520fb131d84adbf559d72ff74">connectHeadportToPort</a> (<a class="el" href="class_h_s_m_1_1_queue_head_port.html">QueueHeadPort</a> &amp;headPort, <a class="el" href="class_h_s_m_1_1_abstract_connectable_port.html">AbstractConnectablePort</a> &amp;port, unsigned short instance) override</td></tr>
<tr class="memdesc:aadb9781520fb131d84adbf559d72ff74"><td class="mdescLeft">&#160;</td><td class="mdescRight">connect headport to its port. <br /></td></tr>
<tr class="separator:aadb9781520fb131d84adbf559d72ff74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708f1db894e97e7c0d6a6376bc24715e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a708f1db894e97e7c0d6a6376bc24715e">setLoggingThresholdTime</a> (long long thresholdTime)</td></tr>
<tr class="separator:a708f1db894e97e7c0d6a6376bc24715e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6a483df4013cca9c0c48e842ac88da"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a7a6a483df4013cca9c0c48e842ac88da">toggleWindViewEvents</a> ()</td></tr>
<tr class="separator:a7a6a483df4013cca9c0c48e842ac88da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5878bec2676e8ad976a3992688650118"><td class="memItemLeft" align="right" valign="top"><a id="a5878bec2676e8ad976a3992688650118"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a5878bec2676e8ad976a3992688650118">processInputQueueInternal</a> (bool processOnlyOneEvent)</td></tr>
<tr class="memdesc:a5878bec2676e8ad976a3992688650118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a5878bec2676e8ad976a3992688650118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bb45e8e57aa89e531f8c4e7797b4c2"><td class="memItemLeft" align="right" valign="top"><a id="a84bb45e8e57aa89e531f8c4e7797b4c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#a84bb45e8e57aa89e531f8c4e7797b4c2">cancelEvent</a> (const <a class="el" href="class_h_s_m_1_1_abstract_local_in_port.html">AbstractLocalInPort</a> &amp;port)</td></tr>
<tr class="memdesc:a84bb45e8e57aa89e531f8c4e7797b4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:a84bb45e8e57aa89e531f8c4e7797b4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6e898140dffbde502094b3a3c7c252"><td class="memItemLeft" align="right" valign="top"><a id="afa6e898140dffbde502094b3a3c7c252"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object.html#afa6e898140dffbde502094b3a3c7c252">dispatch</a> (const <a class="el" href="class_h_s_m_1_1_event_impl_packed.html">EventImplPacked</a> &amp;event, const <a class="el" href="class_h_s_m_1_1_local_in_port.html">LocalInPort</a> &amp;port)</td></tr>
<tr class="memdesc:afa6e898140dffbde502094b3a3c7c252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logging object, same as given to ctor. <br /></td></tr>
<tr class="separator:afa6e898140dffbde502094b3a3c7c252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_class_h_s_m_1_1_active_object_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_h_s_m_1_1_active_object_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_h_s_m_1_1_active_object_base.html">HSM::ActiveObjectBase</a></td></tr>
<tr class="memitem:a5d5c20a625b8cb4dca458922a4d311d5 inherit pub_methods_class_h_s_m_1_1_active_object_base"><td class="memItemLeft" align="right" valign="top"><a id="a5d5c20a625b8cb4dca458922a4d311d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ActiveObjectBase</b> (const <a class="el" href="class_h_s_m_1_1_active_object_base.html">ActiveObjectBase</a> &amp;right)=delete</td></tr>
<tr class="separator:a5d5c20a625b8cb4dca458922a4d311d5 inherit pub_methods_class_h_s_m_1_1_active_object_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5eb2712bcd9d45ee0537a5c89af3286 inherit pub_methods_class_h_s_m_1_1_active_object_base"><td class="memItemLeft" align="right" valign="top"><a id="af5eb2712bcd9d45ee0537a5c89af3286"></a>
<a class="el" href="class_h_s_m_1_1_active_object_base.html">ActiveObjectBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_h_s_m_1_1_active_object_base.html">ActiveObjectBase</a> &amp;right)=delete</td></tr>
<tr class="separator:af5eb2712bcd9d45ee0537a5c89af3286 inherit pub_methods_class_h_s_m_1_1_active_object_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717fb7d45468a0b619580cde5a3510d0 inherit pub_methods_class_h_s_m_1_1_active_object_base"><td class="memItemLeft" align="right" valign="top"><a id="a717fb7d45468a0b619580cde5a3510d0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object_base.html#a717fb7d45468a0b619580cde5a3510d0">wakeUp</a> ()=0</td></tr>
<tr class="memdesc:a717fb7d45468a0b619580cde5a3510d0 inherit pub_methods_class_h_s_m_1_1_active_object_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">this method are only to be called by the framework itself <br /></td></tr>
<tr class="separator:a717fb7d45468a0b619580cde5a3510d0 inherit pub_methods_class_h_s_m_1_1_active_object_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332290413c379b3d02b536a11bfa2be1 inherit pub_methods_class_h_s_m_1_1_active_object_base"><td class="memItemLeft" align="right" valign="top"><a id="a332290413c379b3d02b536a11bfa2be1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_active_object_base.html#a332290413c379b3d02b536a11bfa2be1">getThreadId</a> () const =0</td></tr>
<tr class="memdesc:a332290413c379b3d02b536a11bfa2be1 inherit pub_methods_class_h_s_m_1_1_active_object_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">this method are only to be called by the framework itself <br /></td></tr>
<tr class="separator:a332290413c379b3d02b536a11bfa2be1 inherit pub_methods_class_h_s_m_1_1_active_object_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_h_s_m_1_1_container_common"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_h_s_m_1_1_container_common')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_h_s_m_1_1_container_common.html">HSM::ContainerCommon</a></td></tr>
<tr class="memitem:a16c80a807a0a57dfb1e9efe33c534dec inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="a16c80a807a0a57dfb1e9efe33c534dec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#a16c80a807a0a57dfb1e9efe33c534dec">ContainerCommon</a> (<a class="el" href="class_h_s_m_1_1_active_object_base.html">ActiveObjectBase</a> &amp;activeObject, <a class="el" href="class_h_s_m_1_1_container_common.html">ContainerCommon</a> &amp;parentContainer, std::string name)</td></tr>
<tr class="memdesc:a16c80a807a0a57dfb1e9efe33c534dec inherit pub_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a container with a runtime context (activeObject) a parent container and a name which is used for debug purpsoses. <br /></td></tr>
<tr class="separator:a16c80a807a0a57dfb1e9efe33c534dec inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ab0937ba17b9fdc6472a904d98752a inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="a15ab0937ba17b9fdc6472a904d98752a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ContainerCommon</b> (const <a class="el" href="class_h_s_m_1_1_container_common.html">ContainerCommon</a> &amp;right)=delete</td></tr>
<tr class="separator:a15ab0937ba17b9fdc6472a904d98752a inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad088db6ed67625bc5c8b9736097513ee inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="ad088db6ed67625bc5c8b9736097513ee"></a>
<a class="el" href="class_h_s_m_1_1_container_common.html">ContainerCommon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_h_s_m_1_1_container_common.html">ContainerCommon</a> &amp;right)=delete</td></tr>
<tr class="separator:ad088db6ed67625bc5c8b9736097513ee inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3b6130163e7eb9872126aeee97a6ce inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#a2d3b6130163e7eb9872126aeee97a6ce">init</a> (bool forceReInit)</td></tr>
<tr class="memdesc:a2d3b6130163e7eb9872126aeee97a6ce inherit pub_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated do not override this method.  <a href="class_h_s_m_1_1_container_common.html#a2d3b6130163e7eb9872126aeee97a6ce">More...</a><br /></td></tr>
<tr class="separator:a2d3b6130163e7eb9872126aeee97a6ce inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd6534dec69bc61986e342356622742 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#addd6534dec69bc61986e342356622742">shutdown</a> ()</td></tr>
<tr class="memdesc:addd6534dec69bc61986e342356622742 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated do not override this method.  <a href="class_h_s_m_1_1_container_common.html#addd6534dec69bc61986e342356622742">More...</a><br /></td></tr>
<tr class="separator:addd6534dec69bc61986e342356622742 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe38b09a8f8acc47aea76b7570b3eff inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="afbe38b09a8f8acc47aea76b7570b3eff"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#afbe38b09a8f8acc47aea76b7570b3eff">suspend</a> ()</td></tr>
<tr class="memdesc:afbe38b09a8f8acc47aea76b7570b3eff inherit pub_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend all state machines in this container and its sub-containers. <br /></td></tr>
<tr class="separator:afbe38b09a8f8acc47aea76b7570b3eff inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3b27eca16e5977ecd19a49ef2e8178 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="afe3b27eca16e5977ecd19a49ef2e8178"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#afe3b27eca16e5977ecd19a49ef2e8178">resume</a> ()</td></tr>
<tr class="memdesc:afe3b27eca16e5977ecd19a49ef2e8178 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume all state machines in this container and its sub-containers. <br /></td></tr>
<tr class="separator:afe3b27eca16e5977ecd19a49ef2e8178 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe7a5915d83e2fd90f3693360b3c2b6 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="aabe7a5915d83e2fd90f3693360b3c2b6"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#aabe7a5915d83e2fd90f3693360b3c2b6">getName</a> () const</td></tr>
<tr class="memdesc:aabe7a5915d83e2fd90f3693360b3c2b6 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns same name as given in ctor. <br /></td></tr>
<tr class="separator:aabe7a5915d83e2fd90f3693360b3c2b6 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d2af6da8a5aae897cebf3cb3f3a999 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="a81d2af6da8a5aae897cebf3cb3f3a999"></a>
const std::set&lt; <a class="el" href="class_h_s_m_1_1_state_machine_base.html">HSM::StateMachineBase</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#a81d2af6da8a5aae897cebf3cb3f3a999">getRegisteredStateMachines</a> () const</td></tr>
<tr class="memdesc:a81d2af6da8a5aae897cebf3cb3f3a999 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all event handler which previosly have been registered with <a class="el" href="class_h_s_m_1_1_container_common.html#ab5ee2d26c35abbd951202cbf434b2286">HSM::ContainerCommon::registerStateMachine</a>. <br /></td></tr>
<tr class="separator:a81d2af6da8a5aae897cebf3cb3f3a999 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ee2d26c35abbd951202cbf434b2286 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="ab5ee2d26c35abbd951202cbf434b2286"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#ab5ee2d26c35abbd951202cbf434b2286">registerStateMachine</a> (<a class="el" href="class_h_s_m_1_1_state_machine_base.html">StateMachineBase</a> &amp;stateMachine) const</td></tr>
<tr class="memdesc:ab5ee2d26c35abbd951202cbf434b2286 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps a reference to given event handler but does not maintain the ownership of it. <br /></td></tr>
<tr class="separator:ab5ee2d26c35abbd951202cbf434b2286 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecde5e44d16a3f700ae5cc2bf40682b6 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="aecde5e44d16a3f700ae5cc2bf40682b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#aecde5e44d16a3f700ae5cc2bf40682b6">unregisterStateMachine</a> (<a class="el" href="class_h_s_m_1_1_state_machine_base.html">StateMachineBase</a> &amp;stateMachine) const</td></tr>
<tr class="memdesc:aecde5e44d16a3f700ae5cc2bf40682b6 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes reference of the previosly regisetered event handler and cancels all pending events for that handler from the event queue. <br /></td></tr>
<tr class="separator:aecde5e44d16a3f700ae5cc2bf40682b6 inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4b03e5416a3a5869cff74941a804dd inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="aec4b03e5416a3a5869cff74941a804dd"></a>
const std::set&lt; <a class="el" href="class_h_s_m_1_1_container_common.html">HSM::ContainerCommon</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#aec4b03e5416a3a5869cff74941a804dd">getRegisteredSubContainers</a> () const</td></tr>
<tr class="memdesc:aec4b03e5416a3a5869cff74941a804dd inherit pub_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all containers where this is a parent of. <br /></td></tr>
<tr class="separator:aec4b03e5416a3a5869cff74941a804dd inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189c9e5802343ec4ca83d18e05dbd5eb inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="a189c9e5802343ec4ca83d18e05dbd5eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#a189c9e5802343ec4ca83d18e05dbd5eb">registerSubContainer</a> (<a class="el" href="class_h_s_m_1_1_container_common.html">ContainerCommon</a> &amp;subContainer)</td></tr>
<tr class="memdesc:a189c9e5802343ec4ca83d18e05dbd5eb inherit pub_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps a reference to given container but does not maintain the ownership of it. <br /></td></tr>
<tr class="separator:a189c9e5802343ec4ca83d18e05dbd5eb inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ad2356d96b12bb8d21ef21fcaddbfa inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="aa3ad2356d96b12bb8d21ef21fcaddbfa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#aa3ad2356d96b12bb8d21ef21fcaddbfa">unregisterSubContainer</a> (<a class="el" href="class_h_s_m_1_1_container_common.html">ContainerCommon</a> &amp;subContainer)</td></tr>
<tr class="memdesc:aa3ad2356d96b12bb8d21ef21fcaddbfa inherit pub_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes reference of previosly registered container. <br /></td></tr>
<tr class="separator:aa3ad2356d96b12bb8d21ef21fcaddbfa inherit pub_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_h_s_m_1_1_abstract_input_queue"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_h_s_m_1_1_abstract_input_queue')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_h_s_m_1_1_abstract_input_queue.html">HSM::AbstractInputQueue</a></td></tr>
<tr class="memitem:a0994d809903c01a98bef0662771b78ec inherit pub_methods_class_h_s_m_1_1_abstract_input_queue"><td class="memItemLeft" align="right" valign="top"><a id="a0994d809903c01a98bef0662771b78ec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AbstractInputQueue</b> (const <a class="el" href="class_h_s_m_1_1_abstract_input_queue.html">AbstractInputQueue</a> &amp;right)=delete</td></tr>
<tr class="separator:a0994d809903c01a98bef0662771b78ec inherit pub_methods_class_h_s_m_1_1_abstract_input_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6deda71e103afee694471672a24d39d2 inherit pub_methods_class_h_s_m_1_1_abstract_input_queue"><td class="memItemLeft" align="right" valign="top"><a id="a6deda71e103afee694471672a24d39d2"></a>
<a class="el" href="class_h_s_m_1_1_abstract_input_queue.html">AbstractInputQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_h_s_m_1_1_abstract_input_queue.html">AbstractInputQueue</a> &amp;right)=delete</td></tr>
<tr class="separator:a6deda71e103afee694471672a24d39d2 inherit pub_methods_class_h_s_m_1_1_abstract_input_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_h_s_m_1_1_active_object_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_h_s_m_1_1_active_object_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_h_s_m_1_1_active_object_base.html">HSM::ActiveObjectBase</a></td></tr>
<tr class="memitem:a2b2cc0d628ec8e1f9c49ba3d683d7f44 inherit pro_methods_class_h_s_m_1_1_active_object_base"><td class="memItemLeft" align="right" valign="top"><a id="a2b2cc0d628ec8e1f9c49ba3d683d7f44"></a>
virtual <a class="el" href="class_h_s_m_1_1_sync_object.html">SyncObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getThreadCrossingMutex</b> ()=0</td></tr>
<tr class="separator:a2b2cc0d628ec8e1f9c49ba3d683d7f44 inherit pro_methods_class_h_s_m_1_1_active_object_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_h_s_m_1_1_container_common"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_h_s_m_1_1_container_common')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_h_s_m_1_1_container_common.html">HSM::ContainerCommon</a></td></tr>
<tr class="memitem:a6e101c595e4195ccd52ca7cd71b6e833 inherit pro_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#a6e101c595e4195ccd52ca7cd71b6e833">initContainer</a> ()</td></tr>
<tr class="memdesc:a6e101c595e4195ccd52ca7cd71b6e833 inherit pro_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this empty method for special initialization of the container itself.  <a href="class_h_s_m_1_1_container_common.html#a6e101c595e4195ccd52ca7cd71b6e833">More...</a><br /></td></tr>
<tr class="separator:a6e101c595e4195ccd52ca7cd71b6e833 inherit pro_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf674fef5bc24aaa3777ac071f451d04 inherit pro_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#abf674fef5bc24aaa3777ac071f451d04">shutdownContainer</a> ()</td></tr>
<tr class="memdesc:abf674fef5bc24aaa3777ac071f451d04 inherit pro_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this empty method for special shutdown of the container itself.  <a href="class_h_s_m_1_1_container_common.html#abf674fef5bc24aaa3777ac071f451d04">More...</a><br /></td></tr>
<tr class="separator:abf674fef5bc24aaa3777ac071f451d04 inherit pro_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe5c57dbf9416a7edc442016100a763 inherit pro_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="a5fe5c57dbf9416a7edc442016100a763"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#a5fe5c57dbf9416a7edc442016100a763">initStateMachines</a> (bool forceReInit)</td></tr>
<tr class="memdesc:a5fe5c57dbf9416a7edc442016100a763 inherit pro_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="class_h_s_m_1_1_container_common.html#a6e101c595e4195ccd52ca7cd71b6e833">HSM::ContainerCommon::initContainer()</a> then intializes all registered event handlers and then calls initStateMachines on all registered subcontainers. <br /></td></tr>
<tr class="separator:a5fe5c57dbf9416a7edc442016100a763 inherit pro_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a234588073f26ae40f638da8f08e65e inherit pro_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="a3a234588073f26ae40f638da8f08e65e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#a3a234588073f26ae40f638da8f08e65e">initStateMachines</a> ()</td></tr>
<tr class="memdesc:a3a234588073f26ae40f638da8f08e65e inherit pro_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as initContainer(true). <br /></td></tr>
<tr class="separator:a3a234588073f26ae40f638da8f08e65e inherit pro_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc517538f0a7dac821efa4094ea7ec43 inherit pro_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="acc517538f0a7dac821efa4094ea7ec43"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#acc517538f0a7dac821efa4094ea7ec43">shutdownStateMachines</a> ()</td></tr>
<tr class="memdesc:acc517538f0a7dac821efa4094ea7ec43 inherit pro_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls shutdownStateMachines on all registered subcontainers then shutsdown all all registered event handlers and then calls <a class="el" href="class_h_s_m_1_1_container_common.html#abf674fef5bc24aaa3777ac071f451d04">HSM::ContainerCommon::shutdownContainer()</a>. <br /></td></tr>
<tr class="separator:acc517538f0a7dac821efa4094ea7ec43 inherit pro_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1800a758addb7f9ebeb78f49ab9b63fa inherit pro_methods_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="a1800a758addb7f9ebeb78f49ab9b63fa"></a>
<a class="el" href="class_h_s_m_1_1_container_common.html">ContainerCommon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#a1800a758addb7f9ebeb78f49ab9b63fa">getContainer</a> ()</td></tr>
<tr class="memdesc:a1800a758addb7f9ebeb78f49ab9b63fa inherit pro_methods_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns *this. <br /></td></tr>
<tr class="separator:a1800a758addb7f9ebeb78f49ab9b63fa inherit pro_methods_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_h_s_m_1_1_container_common"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_h_s_m_1_1_container_common')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_h_s_m_1_1_container_common.html">HSM::ContainerCommon</a></td></tr>
<tr class="memitem:a83c849fb6a48efaca51085ebc12b1ad1 inherit pro_attribs_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="a83c849fb6a48efaca51085ebc12b1ad1"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#a83c849fb6a48efaca51085ebc12b1ad1">m_name</a></td></tr>
<tr class="memdesc:a83c849fb6a48efaca51085ebc12b1ad1 inherit pro_attribs_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of this container (same as given in ctor). <br /></td></tr>
<tr class="separator:a83c849fb6a48efaca51085ebc12b1ad1 inherit pro_attribs_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74d15417cca960a266e174635ca4f70 inherit pro_attribs_class_h_s_m_1_1_container_common"><td class="memItemLeft" align="right" valign="top"><a id="ad74d15417cca960a266e174635ca4f70"></a>
std::set&lt; <a class="el" href="class_h_s_m_1_1_container_common.html">ContainerCommon</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_container_common.html#ad74d15417cca960a266e174635ca4f70">m_subContainers</a></td></tr>
<tr class="memdesc:ad74d15417cca960a266e174635ca4f70 inherit pro_attribs_class_h_s_m_1_1_container_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all registered subcontainers. <br /></td></tr>
<tr class="separator:ad74d15417cca960a266e174635ca4f70 inherit pro_attribs_class_h_s_m_1_1_container_common"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Runtime context (thread/process) of a set of event-handlers (e.g. state machines). </p>
<p>Contains an event queue which is shared by all the aggregated event-handlers. Event-Handlers are registered here and initialized afterwards. If an event is send via an outport it gets pushed back into the event-queue. By calling <a class="el" href="class_h_s_m_1_1_active_object.html#add97ff4b7d01fd6f5c6227228cbb19f6" title="Dispatches all events from the event queue to their corresponding event handlers until the event queu...">runOnce()</a> all events get dispatched to the corresponding event-handler until the queue is empty. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac12cbb6fddc57891dcfa1c9e379d3697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12cbb6fddc57891dcfa1c9e379d3697">&#9670;&nbsp;</a></span>cancelEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HSM::ActiveObject::cancelEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_s_m_1_1_local_in_port.html">LocalInPort</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks event within the event queue from given port with given signal as canceled. </p>
<p>Searches the event queue to find the "to be canceled event". When found it is not removed from the event queue but marked as not to be dispatched. </p>

<p>Implements <a class="el" href="class_h_s_m_1_1_active_object_base.html#aac625ccd2ac3761fe2d311416320b29b">HSM::ActiveObjectBase</a>.</p>

</div>
</div>
<a id="a5b8f3923051d2271303e6de9112c3667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8f3923051d2271303e6de9112c3667">&#9670;&nbsp;</a></span>cancelEvents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HSM::ActiveObject::cancelEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_s_m_1_1_local_in_port.html">LocalInPort</a> &amp;&#160;</td>
          <td class="paramname"><em>localInPort</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks all events within the event queue which are to be dispatched to the given port as canceled. </p>
<p>Searches the event queue to find the "to be canceled event". When found it is not removed from the event queue but marked as not to be dispatched. </p>

<p>Implements <a class="el" href="class_h_s_m_1_1_active_object_base.html#ad9856cb7cb179366ff57b50b4613cb7b">HSM::ActiveObjectBase</a>.</p>

</div>
</div>
<a id="aa592f6ec0d42b68f336ecb2c5884b3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa592f6ec0d42b68f336ecb2c5884b3d5">&#9670;&nbsp;</a></span>cancelEvents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HSM::ActiveObject::cancelEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_s_m_1_1_state_machine_base.html">StateMachineBase</a> &amp;&#160;</td>
          <td class="paramname"><em>stateMachine</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks all events within the event queue which are to be dispatched to the given event handler as canceled. </p>
<p>Searches the event queue to find the "to be canceled event". When found it is not removed from the event queue but marked as not to be dispatched. </p>

<p>Implements <a class="el" href="class_h_s_m_1_1_active_object_base.html#a004112625466f0cada9f5b9363a68f40">HSM::ActiveObjectBase</a>.</p>

</div>
</div>
<a id="ae236506cd846ba8087764d3ec0218d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae236506cd846ba8087764d3ec0218d7d">&#9670;&nbsp;</a></span>getQueueFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a>* HSM::ActiveObject::getQueueFrom </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>otherThreadName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If two active-objects are connected one needs to be able to put events into the event queue of the otherone, this can be done with this method. </p>
<p>The other active-object has to be registered to this with a call to <a class="el" href="class_h_s_m_1_1_active_object.html#af27fffb756d56f233e6d247c7c5e5e3b">HSM::ActiveObject::makeQueueFrom</a>. </p>

<p>Implements <a class="el" href="class_h_s_m_1_1_active_object_base.html#a0f3c429658746af59e6f99165ac9e03c">HSM::ActiveObjectBase</a>.</p>

</div>
</div>
<a id="a93bcdfad3b0d97a1d7d21784cf5ec1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bcdfad3b0d97a1d7d21784cf5ec1b6">&#9670;&nbsp;</a></span>logMaxFillLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HSM::ActiveObject::logMaxFillLevels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>logs the max fill levels of the event queue and the internal queue </p>

</div>
</div>
<a id="ae9e92d44b392f234bf9c62606ad6da09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e92d44b392f234bf9c62606ad6da09">&#9670;&nbsp;</a></span>makeQueueFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a>* HSM::ActiveObject::makeQueueFrom </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>otherThreadName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same semantics as <a class="el" href="class_h_s_m_1_1_active_object.html#af27fffb756d56f233e6d247c7c5e5e3b">HSM::ActiveObject::makeQueueFrom</a>, but this method is necessary to create a queue to be used by ports that are not running on ActiveObjects. </p>
<p>Those ports have to be constructed using a string parameter owner which has to have the same value as the otherThreadName parameter of this method. If such isolated ports are running on different threads, one queue per thread has to be created by calling this method, and the string is used to identify the queue instance. </p><dl class="section return"><dt>Returns</dt><dd>the queue to the other thread </dd></dl>

</div>
</div>
<a id="a5ac3140297357c7371e7d409988a35a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac3140297357c7371e7d409988a35a2">&#9670;&nbsp;</a></span>post()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HSM::ActiveObject::post </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_s_m_1_1_event_impl.html">EventImpl</a> &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_s_m_1_1_local_in_port.html">LocalInPort</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>portInstance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts the given event received by given port on given port instance into the event queue. </p>
<p>If queue is full the content is dumped into log and an exception is thrown. </p>

<p>Implements <a class="el" href="class_h_s_m_1_1_active_object_base.html#ad97fe46531f25522c7c2a23cbbacfb88">HSM::ActiveObjectBase</a>.</p>

</div>
</div>
<a id="a63e1475f65a571c1d59b576c3ff52faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e1475f65a571c1d59b576c3ff52faa">&#9670;&nbsp;</a></span>postInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HSM::ActiveObject::postInternal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_s_m_1_1_event_impl.html">EventImpl</a> &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_s_m_1_1_local_in_port.html">LocalInPort</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>portInstance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts the given event received by given port on given port instance into the internal event queue. </p>
<p>If queue is full the content is dumped into log and an exception is thrown. </p>

<p>Implements <a class="el" href="class_h_s_m_1_1_active_object_base.html#a05b6c074da49cf9f37f408ba76a8d5f5">HSM::ActiveObjectBase</a>.</p>

</div>
</div>
<a id="a8423628952b443a3cb984e2b76c06ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8423628952b443a3cb984e2b76c06ab8">&#9670;&nbsp;</a></span>processInputQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HSM::ActiveObject::processInputQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes all events from an event queue which is connected to another active object. </p>
<p>If <a class="el" href="class_h_s_m_1_1_active_object.html#af27fffb756d56f233e6d247c7c5e5e3b">HSM::ActiveObject::makeQueueFrom()</a> has never been called this call returns immediately. Otherwise all created queues are locked and the events are dispatched to the corresponding event handlers until all queues are empty. The QueueConnectInterface::HSM_DISCONNECT is handled here too and disconnects and deletes the port connected to the corresponding event queue. </p>

<p>Implements <a class="el" href="class_h_s_m_1_1_abstract_input_queue.html">HSM::AbstractInputQueue</a>.</p>

</div>
</div>
<a id="ae267ff403d915c6864bfd48f5311bcb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae267ff403d915c6864bfd48f5311bcb0">&#9670;&nbsp;</a></span>processInputQueueSingle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HSM::ActiveObject::processInputQueueSingle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes one event from an event queue which is connected to another active object. </p>
<p>If <a class="el" href="class_h_s_m_1_1_active_object.html#af27fffb756d56f233e6d247c7c5e5e3b">HSM::ActiveObject::makeQueueFrom()</a> has never been called this call returns immediately. Otherwise all created queues are locked and one event is dispatched to the corresponding event handler. The QueueConnectInterface::HSM_DISCONNECT is handled here too and disconnects and deletes the port connected to the corresponding event queue. </p>

</div>
</div>
<a id="add97ff4b7d01fd6f5c6227228cbb19f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add97ff4b7d01fd6f5c6227228cbb19f6">&#9670;&nbsp;</a></span>runOnce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HSM::ActiveObject::runOnce </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatches all events from the event queue to their corresponding event handlers until the event queue is empty. </p>
<p>Basically <a class="el" href="class_h_s_m_1_1_active_object.html#a3a55a3dabb13dc251bc9da770071e1d7">HSM::ActiveObject::runSingleLoop()</a> is called until it returns false. </p>

</div>
</div>
<a id="a3a55a3dabb13dc251bc9da770071e1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a55a3dabb13dc251bc9da770071e1d7">&#9670;&nbsp;</a></span>runSingleLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HSM::ActiveObject::runSingleLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatches one event from the event queue to its corresponding event handler. </p>
<p>Afterwards all events from the internal event queue are dispatched. </p><dl class="section note"><dt>Note</dt><dd>This method should only be used if you want to explicitly give up controll from the current context since the dispatching of all events would take too long. But be aware that this might increase the amount of undispatched events over time which might lead to an excption if the memory of the event queue is exhausted. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if there are still events to be dispatched, otherwise false. </dd></dl>

</div>
</div>
<a id="a708f1db894e97e7c0d6a6376bc24715e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708f1db894e97e7c0d6a6376bc24715e">&#9670;&nbsp;</a></span>setLoggingThresholdTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void HSM::ActiveObject::setLoggingThresholdTime </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>thresholdTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>log duration of dispatches that take thresholdTime (in micro seconds) or longer thresholdTime &lt; 0 implies no logging (default) </p>

</div>
</div>
<a id="a8c14b3d0a064b52665725c865f35879a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c14b3d0a064b52665725c865f35879a">&#9670;&nbsp;</a></span>setWriterTaskId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HSM::ActiveObject::setWriterTaskId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable debug functionality: Set the task id of the current thread as the writer thread for the event queue. After setting this the write-accesses to the queue (push) will be checked whether the queue is written only be the same thread. If a different thread tries to write, push will throw an exception. </p>

<p>Implements <a class="el" href="class_h_s_m_1_1_active_object_base.html#ac6a46d1e9ff7b1176d8dc26393ddce7a">HSM::ActiveObjectBase</a>.</p>

</div>
</div>
<a id="a7a6a483df4013cca9c0c48e842ac88da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6a483df4013cca9c0c48e842ac88da">&#9670;&nbsp;</a></span>toggleWindViewEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void HSM::ActiveObject::toggleWindViewEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>enable/disable WindView <a class="el" href="class_h_s_m_1_1_event.html" title="Event class that contains the basic data necessary to send events through ports.">Event</a> #1 and #2 around all dispatches (default off) </p>

</div>
</div>
<a id="a30389b9634cd0d29ac8c3f6ad0b16013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30389b9634cd0d29ac8c3f6ad0b16013">&#9670;&nbsp;</a></span>unsetWriterTaskId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HSM::ActiveObject::unsetWriterTaskId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable debug functionality: Stop checking for wrong write-accesses (see method setWriterTaskId ) </p>

<p>Implements <a class="el" href="class_h_s_m_1_1_active_object_base.html#a07416c3100bda104d6b375c978cac5ae">HSM::ActiveObjectBase</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Framework/HSM/Interface/<a class="el" href="_active_object_8h_source.html">ActiveObject.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 13 2023 13:32:12 for Product Core System (PCS) by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
