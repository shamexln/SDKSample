<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Product Core System (PCS): HSM::EventRingBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Product Core System (PCS)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_h_s_m.html">HSM</a></li><li class="navelem"><a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_h_s_m_1_1_event_ring_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HSM::EventRingBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a ring buffer implementation, which is thread safe under single producer single consumer conditions.  
 <a href="class_h_s_m_1_1_event_ring_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_event_ring_buffer_8h_source.html">Framework/HSM/Internal/EventRingBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_event_ring_buffer_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acbb6c5b3b38a4b102f6cd35f9d916a36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_event_ring_buffer.html#acbb6c5b3b38a4b102f6cd35f9d916a36">EventRingBuffer</a> (size_t bufsize=1000)</td></tr>
<tr class="separator:acbb6c5b3b38a4b102f6cd35f9d916a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504cc7b5ca57ee569b6dd835384cf749"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_event_ring_buffer.html#a504cc7b5ca57ee569b6dd835384cf749">EventRingBuffer</a> (std::string name, <a class="el" href="class_h_s_m_1_1_debug_adapter_base.html">DebugAdapterBase</a> *debugAdapter, size_t bufsize)</td></tr>
<tr class="separator:a504cc7b5ca57ee569b6dd835384cf749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41b212d10390e51b209470376e469b4"><td class="memItemLeft" align="right" valign="top"><a id="ac41b212d10390e51b209470376e469b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EventRingBuffer</b> (const <a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a> &amp;)=delete</td></tr>
<tr class="separator:ac41b212d10390e51b209470376e469b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980ced1dd53a1dd720dc8cd8a0d3aff8"><td class="memItemLeft" align="right" valign="top"><a id="a980ced1dd53a1dd720dc8cd8a0d3aff8"></a>
<a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">EventRingBuffer</a> &amp;)=delete</td></tr>
<tr class="separator:a980ced1dd53a1dd720dc8cd8a0d3aff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad222c757109c9aac377700cc3ef12bfc"><td class="memItemLeft" align="right" valign="top"><a id="ad222c757109c9aac377700cc3ef12bfc"></a>
<a class="el" href="class_h_s_m_1_1_event_ring_buffer_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:ad222c757109c9aac377700cc3ef12bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ce023c74a97c88faba882593b84952"><td class="memItemLeft" align="right" valign="top"><a id="af4ce023c74a97c88faba882593b84952"></a>
<a class="el" href="class_h_s_m_1_1_event_ring_buffer_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:af4ce023c74a97c88faba882593b84952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada76a73c57ab52abf5ea22f8eeee1d61"><td class="memItemLeft" align="right" valign="top"><a id="ada76a73c57ab52abf5ea22f8eeee1d61"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:ada76a73c57ab52abf5ea22f8eeee1d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927ce57384adb960b34d6836d25774d2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_event_ring_buffer.html#a927ce57384adb960b34d6836d25774d2">size</a> () const</td></tr>
<tr class="separator:a927ce57384adb960b34d6836d25774d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602b2a56b87b51770d577ec41b4595ec"><td class="memItemLeft" align="right" valign="top"><a id="a602b2a56b87b51770d577ec41b4595ec"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxFillLevel</b> () const</td></tr>
<tr class="separator:a602b2a56b87b51770d577ec41b4595ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd4d908cb16bc67116a577b95dd657b"><td class="memItemLeft" align="right" valign="top"><a id="a4cd4d908cb16bc67116a577b95dd657b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getQueueSize</b> () const</td></tr>
<tr class="separator:a4cd4d908cb16bc67116a577b95dd657b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e2dd433f3e43addae8e7d2bf320f17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_event_ring_buffer.html#a12e2dd433f3e43addae8e7d2bf320f17">setWriterTaskId</a> ()</td></tr>
<tr class="separator:a12e2dd433f3e43addae8e7d2bf320f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758b9e46819828ca2bf0c779c0bc8419"><td class="memItemLeft" align="right" valign="top"><a id="a758b9e46819828ca2bf0c779c0bc8419"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_event_ring_buffer.html#a758b9e46819828ca2bf0c779c0bc8419">unsetWriterTaskId</a> ()</td></tr>
<tr class="memdesc:a758b9e46819828ca2bf0c779c0bc8419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset the writer task ID and stop checking wrong access. <br /></td></tr>
<tr class="separator:a758b9e46819828ca2bf0c779c0bc8419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa606c9fa94942c3a6c2eb4b2a15be2a"><td class="memItemLeft" align="right" valign="top"><a id="afa606c9fa94942c3a6c2eb4b2a15be2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:afa606c9fa94942c3a6c2eb4b2a15be2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4050070ab8a52e0f66936e87b02ad5"><td class="memItemLeft" align="right" valign="top"><a id="a0b4050070ab8a52e0f66936e87b02ad5"></a>
const <a class="el" href="class_h_s_m_1_1_event_impl_packed.html">EventImplPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getFront</b> () const</td></tr>
<tr class="separator:a0b4050070ab8a52e0f66936e87b02ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc1a8bffaa0d08efbe56cad9ed8e503"><td class="memItemLeft" align="right" valign="top"><a id="acfc1a8bffaa0d08efbe56cad9ed8e503"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_event_ring_buffer.html#acfc1a8bffaa0d08efbe56cad9ed8e503">pop</a> ()</td></tr>
<tr class="memdesc:acfc1a8bffaa0d08efbe56cad9ed8e503"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a consumer method. <br /></td></tr>
<tr class="separator:acfc1a8bffaa0d08efbe56cad9ed8e503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff387a6a972ed8235717bfcb667f1e63"><td class="memItemLeft" align="right" valign="top"><a id="aff387a6a972ed8235717bfcb667f1e63"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_event_ring_buffer.html#aff387a6a972ed8235717bfcb667f1e63">push</a> (const <a class="el" href="class_h_s_m_1_1_event_impl_packed.html">EventImplPacked</a> &amp;event, const void *data)</td></tr>
<tr class="memdesc:aff387a6a972ed8235717bfcb667f1e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a producer method. <br /></td></tr>
<tr class="separator:aff387a6a972ed8235717bfcb667f1e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144e6d87d23569d1322392ba14d6100c"><td class="memItemLeft" align="right" valign="top"><a id="a144e6d87d23569d1322392ba14d6100c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpEventQueue</b> (<a class="el" href="class_h_s_m_1_1_debug_adapter_base.html">DebugAdapterBase</a> &amp;debugAdapter) const</td></tr>
<tr class="separator:a144e6d87d23569d1322392ba14d6100c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae623c10cd1d86fc37ccb93a79e39e562"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_event_ring_buffer.html#ae623c10cd1d86fc37ccb93a79e39e562">dumpEventQueueThrowException</a> (<a class="el" href="class_h_s_m_1_1_debug_adapter_base.html">DebugAdapterBase</a> &amp;, const char *const exceptionText)</td></tr>
<tr class="separator:ae623c10cd1d86fc37ccb93a79e39e562"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2f8f99068d5eb990d42ce3fb9d1009fb"><td class="memItemLeft" align="right" valign="top"><a id="a2f8f99068d5eb990d42ce3fb9d1009fb"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>maxRead</b> (const unsigned char *localWritePtr, const unsigned char *localReadPtr) const</td></tr>
<tr class="separator:a2f8f99068d5eb990d42ce3fb9d1009fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97c0aece23118154987041dd6f27953"><td class="memItemLeft" align="right" valign="top"><a id="aa97c0aece23118154987041dd6f27953"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>maxWrite</b> (const unsigned char *localWritePtr, const unsigned char *localReadPtr) const</td></tr>
<tr class="separator:aa97c0aece23118154987041dd6f27953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3828f53ab6813165521904e88c12263"><td class="memItemLeft" align="right" valign="top"><a id="ad3828f53ab6813165521904e88c12263"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculateMaxFillLevel</b> (const unsigned char *localWritePtr, const unsigned char *localReadPtr)</td></tr>
<tr class="separator:ad3828f53ab6813165521904e88c12263"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a6bb8a0daa1db71b6ef6383df3bb46329"><td class="memItemLeft" align="right" valign="top"><a id="a6bb8a0daa1db71b6ef6383df3bb46329"></a>
std::atomic&lt; unsigned char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_writePtr</b> {}</td></tr>
<tr class="separator:a6bb8a0daa1db71b6ef6383df3bb46329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15e910998dfd16d50ebdb51b722baf3"><td class="memItemLeft" align="right" valign="top"><a id="aa15e910998dfd16d50ebdb51b722baf3"></a>
std::atomic&lt; unsigned char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_readPtr</b> {}</td></tr>
<tr class="separator:aa15e910998dfd16d50ebdb51b722baf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcfb91abd3ea6148dc86c04285bb367"><td class="memItemLeft" align="right" valign="top"><a id="a3bcfb91abd3ea6148dc86c04285bb367"></a>
unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>m_buffer</b></td></tr>
<tr class="separator:a3bcfb91abd3ea6148dc86c04285bb367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504b46e16202c9341f4eed1bb781484a"><td class="memItemLeft" align="right" valign="top"><a id="a504b46e16202c9341f4eed1bb781484a"></a>
unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>m_bufferEnd</b></td></tr>
<tr class="separator:a504b46e16202c9341f4eed1bb781484a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe282040b06e9866b94742279977e52"><td class="memItemLeft" align="right" valign="top"><a id="adfe282040b06e9866b94742279977e52"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_bufSize</b></td></tr>
<tr class="separator:adfe282040b06e9866b94742279977e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31033165994cf512fe60654650e6c431"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_s_m_1_1_event_ring_buffer.html#a31033165994cf512fe60654650e6c431">m_readCount</a> {}</td></tr>
<tr class="separator:a31033165994cf512fe60654650e6c431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e7decf4614d3fb47213446cd326789"><td class="memItemLeft" align="right" valign="top"><a id="aa0e7decf4614d3fb47213446cd326789"></a>
std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_writeCount</b> {}</td></tr>
<tr class="separator:aa0e7decf4614d3fb47213446cd326789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf675c318d1dd55af324bde534accb98"><td class="memItemLeft" align="right" valign="top"><a id="acf675c318d1dd55af324bde534accb98"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_maxFillLevel</b> {0}</td></tr>
<tr class="separator:acf675c318d1dd55af324bde534accb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717b7e36ced659a8cc2e3fe9d3985e0d"><td class="memItemLeft" align="right" valign="top"><a id="a717b7e36ced659a8cc2e3fe9d3985e0d"></a>
std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_dumpLockFlag</b> {}</td></tr>
<tr class="separator:a717b7e36ced659a8cc2e3fe9d3985e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d50d779075bdec75648635f0e1f1a3"><td class="memItemLeft" align="right" valign="top"><a id="ab9d50d779075bdec75648635f0e1f1a3"></a>
<a class="el" href="class_d_f_l_1_1_thread_1_1_id.html">DFL::Thread::Id</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_writerTaskId</b> {}</td></tr>
<tr class="separator:ab9d50d779075bdec75648635f0e1f1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac817becc465a7eeb5467b986f3fbed32"><td class="memItemLeft" align="right" valign="top"><a id="ac817becc465a7eeb5467b986f3fbed32"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>m_name</b></td></tr>
<tr class="separator:ac817becc465a7eeb5467b986f3fbed32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32828353ee8f63683337fe903de42b46"><td class="memItemLeft" align="right" valign="top"><a id="a32828353ee8f63683337fe903de42b46"></a>
<a class="el" href="class_h_s_m_1_1_debug_adapter_base.html">DebugAdapterBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_debugAdapter</b> {nullptr}</td></tr>
<tr class="separator:a32828353ee8f63683337fe903de42b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6c4ef909d0a780b79c227025c12e6b"><td class="memItemLeft" align="right" valign="top"><a id="add6c4ef909d0a780b79c227025c12e6b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_fillLevelWarned</b> {false}</td></tr>
<tr class="separator:add6c4ef909d0a780b79c227025c12e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af0349ae7c496437708c14502c9acdb1a"><td class="memItemLeft" align="right" valign="top"><a id="af0349ae7c496437708c14502c9acdb1a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>EventRingBuffer::iterator</b></td></tr>
<tr class="separator:af0349ae7c496437708c14502c9acdb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33f7285dd603146678177d00e4c0cd2"><td class="memItemLeft" align="right" valign="top"><a id="ac33f7285dd603146678177d00e4c0cd2"></a>
DFL_HSM_EXPIMP friend <a class="el" href="class_h_s_m_1_1_debug_adapter_base.html">DebugAdapterBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="class_h_s_m_1_1_debug_adapter_base.html">DebugAdapterBase</a> &amp;stream, const <a class="el" href="class_h_s_m_1_1_event_ring_buffer.html">HSM::EventRingBuffer</a> &amp;right)</td></tr>
<tr class="separator:ac33f7285dd603146678177d00e4c0cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a ring buffer implementation, which is thread safe under single producer single consumer conditions. </p>
<p>It does not need any synchronization means, because the consumer methods only modify the variable m_readPtr and the producer only modifies m_writePtr. The buffer is never really full, there is always at least one sizeof(EventHeader) free, this is necessary to avoid other synchronization variables to distinguish between buffer full and empty. Events are never split up, even in the wrap-around case. Instead a dummy event is placed to fill the rest of the buffer until the buffer end and the new event is placed at the beginning of the buffer. Therefore it is possible that the getFront() and getNext() methods deliver dummy events, indicated by the signal == HSM::HSM_NONE. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acbb6c5b3b38a4b102f6cd35f9d916a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb6c5b3b38a4b102f6cd35f9d916a36">&#9670;&nbsp;</a></span>EventRingBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HSM::EventRingBuffer::EventRingBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em> = <code>1000</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufsize</td><td>Size of the buffer in bytes, which is allocated once on the heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a504cc7b5ca57ee569b6dd835384cf749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504cc7b5ca57ee569b6dd835384cf749">&#9670;&nbsp;</a></span>EventRingBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HSM::EventRingBuffer::EventRingBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_h_s_m_1_1_debug_adapter_base.html">DebugAdapterBase</a> *&#160;</td>
          <td class="paramname"><em>debugAdapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the buffer </td></tr>
    <tr><td class="paramname">bufsize</td><td>Size of the buffer in bytes, which is allocated once on the heap </td></tr>
    <tr><td class="paramname">debugAdapter</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae623c10cd1d86fc37ccb93a79e39e562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae623c10cd1d86fc37ccb93a79e39e562">&#9670;&nbsp;</a></span>dumpEventQueueThrowException()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void HSM::EventRingBuffer::dumpEventQueueThrowException </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_s_m_1_1_debug_adapter_base.html">DebugAdapterBase</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>exceptionText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Despite the name saying it dumps the event queue and then throws it currently only throws an exception with the given exception text. This has been done because if while events are dumped to the debugAdapter another object from another context tries to access this <a class="el" href="class_h_s_m_1_1_event_ring_buffer.html" title="This is a ring buffer implementation, which is thread safe under single producer single consumer cond...">EventRingBuffer</a> an AccessViolation happens resulting in having no stackdump. Thus for now we just throw an exception. The issue S32-639 will investigate if a more cleaner solution is possible. </p>

</div>
</div>
<a id="a12e2dd433f3e43addae8e7d2bf320f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e2dd433f3e43addae8e7d2bf320f17">&#9670;&nbsp;</a></span>setWriterTaskId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HSM::EventRingBuffer::setWriterTaskId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the task id of the current thread as the writer thread. After setting this the write-accesses (push) will be checked whether they are only called by the same thread. If a different thread tries to write, push will throw an exception </p>

</div>
</div>
<a id="a927ce57384adb960b34d6836d25774d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927ce57384adb960b34d6836d25774d2">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int HSM::EventRingBuffer::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is only for unit-testing purposes and delivers also the number of canceled and dummy events. </p><dl class="section return"><dt>Returns</dt><dd>number of events in the buffer </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a31033165994cf512fe60654650e6c431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31033165994cf512fe60654650e6c431">&#9670;&nbsp;</a></span>m_readCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;unsigned int&gt; HSM::EventRingBuffer::m_readCount {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>these variables are only used to track the number of elements in the queue they are not synchronized with m_writePtr and m_readPtr and cannot be used for full/empty detection </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Framework/HSM/Internal/<a class="el" href="_event_ring_buffer_8h_source.html">EventRingBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 13 2023 13:32:13 for Product Core System (PCS) by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
