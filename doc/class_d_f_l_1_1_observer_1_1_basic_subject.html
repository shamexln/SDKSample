<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Product Core System (PCS): DFL::Observer::BasicSubject&lt; ObserverType, BasicLockable, InvokePolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Product Core System (PCS)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_d_f_l.html">DFL</a></li><li class="navelem"><a class="el" href="namespace_d_f_l_1_1_observer.html">Observer</a></li><li class="navelem"><a class="el" href="class_d_f_l_1_1_observer_1_1_basic_subject.html">BasicSubject</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_d_f_l_1_1_observer_1_1_basic_subject-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DFL::Observer::BasicSubject&lt; ObserverType, BasicLockable, InvokePolicy &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___s32__group.html">S32</a> &raquo; <a class="el" href="group___utils.html">Utils</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic observable container to enable publish-subscribe for smart pointers.  
 <a href="class_d_f_l_1_1_observer_1_1_basic_subject.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_basic_subject_8h_source.html">Framework/Utils/Public/Observer/BasicSubject.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DFL::Observer::BasicSubject&lt; ObserverType, BasicLockable, InvokePolicy &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_d_f_l_1_1_observer_1_1_basic_subject__inherit__graph.png" border="0" usemap="#a_d_f_l_1_1_observer_1_1_basic_subject_3_01_observer_type_00_01_basic_lockable_00_01_invoke_policy_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="a_d_f_l_1_1_observer_1_1_basic_subject_3_01_observer_type_00_01_basic_lockable_00_01_invoke_policy_01_4_inherit__map" id="a_d_f_l_1_1_observer_1_1_basic_subject_3_01_observer_type_00_01_basic_lockable_00_01_invoke_policy_01_4_inherit__map">
<area shape="rect" title="Generic observable container to enable publish&#45;subscribe for smart pointers." alt="" coords="5,189,216,355"/>
<area shape="rect" href="class_s31_1_1_history_1_1_biceps_to_store_mapper.html" title="Mapper between BicepsXml and History interfaces for MDIB changes." alt="" coords="5,403,216,597"/>
<area shape="rect" href="class_d_f_l_1_1_observer_1_1_subject.html" title="Interface for generic observable container." alt="" coords="32,5,189,141"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_observer_1_1_basic_subject_1_1_lock_guard.html">LockGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if no observers exist, otherwise <code>false</code>.  <a href="class_d_f_l_1_1_observer_1_1_basic_subject_1_1_lock_guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a027ceb306b668b2b121a87256458f004"><td class="memItemLeft" align="right" valign="top"><a id="a027ceb306b668b2b121a87256458f004"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_observer_1_1_basic_subject.html#a027ceb306b668b2b121a87256458f004">registerObserver</a> (const std::weak_ptr&lt; ObserverType &gt; &amp;observer) override</td></tr>
<tr class="memdesc:a027ceb306b668b2b121a87256458f004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an observer. <br /></td></tr>
<tr class="separator:a027ceb306b668b2b121a87256458f004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1768b033fd7230f6289dd72674f177"><td class="memItemLeft" align="right" valign="top"><a id="a9d1768b033fd7230f6289dd72674f177"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_observer_1_1_basic_subject.html#a9d1768b033fd7230f6289dd72674f177">unregisterObserver</a> (const std::weak_ptr&lt; ObserverType &gt; &amp;observer) override</td></tr>
<tr class="memdesc:a9d1768b033fd7230f6289dd72674f177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an observer. <br /></td></tr>
<tr class="separator:a9d1768b033fd7230f6289dd72674f177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ca2d761d949cc8f90fb03058f3511c"><td class="memTemplParams" colspan="2">template&lt;class Func &gt; </td></tr>
<tr class="memitem:ab8ca2d761d949cc8f90fb03058f3511c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_observer_1_1_basic_subject.html#ab8ca2d761d949cc8f90fb03058f3511c">notify</a> (Func &amp;&amp;func)</td></tr>
<tr class="memdesc:ab8ca2d761d949cc8f90fb03058f3511c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a notification to all observers.  <a href="class_d_f_l_1_1_observer_1_1_basic_subject.html#ab8ca2d761d949cc8f90fb03058f3511c">More...</a><br /></td></tr>
<tr class="separator:ab8ca2d761d949cc8f90fb03058f3511c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_d_f_l_1_1_observer_1_1_subject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_d_f_l_1_1_observer_1_1_subject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_d_f_l_1_1_observer_1_1_subject.html">DFL::Observer::Subject&lt; ObserverType &gt;</a></td></tr>
<tr class="memitem:aacc70f61a74f803fb989f4cbab03ed09 inherit pub_methods_class_d_f_l_1_1_observer_1_1_subject"><td class="memItemLeft" align="right" valign="top"><a id="aacc70f61a74f803fb989f4cbab03ed09"></a>
<a class="el" href="class_d_f_l_1_1_observer_1_1_subject.html">Subject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_d_f_l_1_1_observer_1_1_subject.html">Subject</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aacc70f61a74f803fb989f4cbab03ed09 inherit pub_methods_class_d_f_l_1_1_observer_1_1_subject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aaafb63e911fa9276638913ede5c4a1c3"><td class="memItemLeft" align="right" valign="top"><a id="aaafb63e911fa9276638913ede5c4a1c3"></a>
std::vector&lt; std::shared_ptr&lt; ObserverType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>removeExpiredSubscriptions</b> ()</td></tr>
<tr class="separator:aaafb63e911fa9276638913ede5c4a1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a313e1c2ea6a0be3f60d35ec92971bf6a"><td class="memItemLeft" align="right" valign="top"><a id="a313e1c2ea6a0be3f60d35ec92971bf6a"></a>
BasicLockable&#160;</td><td class="memItemRight" valign="bottom"><b>m_lockable</b> {}</td></tr>
<tr class="separator:a313e1c2ea6a0be3f60d35ec92971bf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6186dd6b72cecb94354d720bf21cd070"><td class="memItemLeft" align="right" valign="top"><a id="a6186dd6b72cecb94354d720bf21cd070"></a>
std::set&lt; std::weak_ptr&lt; ObserverType &gt;, std::owner_less&lt; std::weak_ptr&lt; ObserverType &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_observers</b> {}</td></tr>
<tr class="separator:a6186dd6b72cecb94354d720bf21cd070"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ObserverType, class BasicLockable, class InvokePolicy&gt;<br />
class DFL::Observer::BasicSubject&lt; ObserverType, BasicLockable, InvokePolicy &gt;</h3>

<p>Generic observable container to enable publish-subscribe for smart pointers. </p>
<p>This is a helper to use the observer design pattern with the following features:</p>
<ul>
<li>Observers here are typically instantiations of (arbitriary) abstract classes ('interfaces')</li>
<li>Observers can be registered/unregistered</li>
<li>Observers are removed automatically if they go out of lifetime</li>
<li>Customizable regarding thread-policy and invoking callbacks when notifying</li>
</ul>
<p>Internally the observers are hold as weak pointers.</p>
<h2><a class="anchor" id="autotoc_md293"></a>
Example</h2>
<p>This observer is generally defined as a virtual abtract interface. </p><div class="fragment"><div class="line"><span class="keyword">class </span>PeerStatus</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~PeerStatus() = <span class="keywordflow">default</span>;</div>
<div class="line">    PeerStatus&amp; operator=(PeerStatus&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> online(<span class="keyword">const</span> std::string&amp; <a class="code" href="group___thread.html#gac1703e2ba8242a295edc326b55cbefd2">name</a>) <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> offline(<span class="keyword">const</span> std::string&amp; <a class="code" href="group___thread.html#gac1703e2ba8242a295edc326b55cbefd2">name</a>) <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
<div class="ttc" id="agroup___thread_html_gac1703e2ba8242a295edc326b55cbefd2"><div class="ttname"><a href="group___thread.html#gac1703e2ba8242a295edc326b55cbefd2">DFL::Thread::ThisThread::name</a></div><div class="ttdeci">DFL_THREAD_EXPIMP std::string name()</div><div class="ttdoc">Same as calling DFL::Thread::name(const DFL::Thread::Id&amp;) with DFL::Thread::ThisThread::id().</div></div>
</div><!-- fragment --><p> Derived from the observer interface there is somewhere an implementation of an actual observer </p><div class="fragment"><div class="line"><span class="keyword">class </span>LogPeerStatus : <span class="keyword">public</span> PeerStatus</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> online(<span class="keyword">const</span> std::string&amp; <a class="code" href="group___thread.html#gac1703e2ba8242a295edc326b55cbefd2">name</a>)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;peer &quot;</span> &lt;&lt; <span class="charliteral">&#39;\&quot;&#39;</span> &lt;&lt; <a class="code" href="group___thread.html#gac1703e2ba8242a295edc326b55cbefd2">name</a> &lt;&lt; <span class="stringliteral">&quot;\&quot; online\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> offline(<span class="keyword">const</span> std::string&amp; <a class="code" href="group___thread.html#gac1703e2ba8242a295edc326b55cbefd2">name</a>)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;peer &quot;</span> &lt;&lt; <span class="charliteral">&#39;\&quot;&#39;</span> &lt;&lt; <a class="code" href="group___thread.html#gac1703e2ba8242a295edc326b55cbefd2">name</a> &lt;&lt; <span class="stringliteral">&quot;\&quot; offline\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ThrowsOnStatusChange : <span class="keyword">public</span> PeerStatus</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> online(<span class="keyword">const</span> std::string&amp; <a class="code" href="group___thread.html#gac1703e2ba8242a295edc326b55cbefd2">name</a>)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">throw</span> std::runtime_error{<span class="stringliteral">&quot;peer: \&quot;&quot;</span> + <a class="code" href="group___thread.html#gac1703e2ba8242a295edc326b55cbefd2">name</a> + <span class="stringliteral">&quot;\&quot;  got online&quot;</span>};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> offline(<span class="keyword">const</span> std::string&amp; <a class="code" href="group___thread.html#gac1703e2ba8242a295edc326b55cbefd2">name</a>)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">throw</span> std::runtime_error{<span class="stringliteral">&quot;peer: \&quot;&quot;</span> + <a class="code" href="group___thread.html#gac1703e2ba8242a295edc326b55cbefd2">name</a> + <span class="stringliteral">&quot;\&quot;  got offline&quot;</span>};</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> The class that holds all observers uses this class as a helper. </p><div class="fragment"><div class="line"><span class="keyword">class </span>PeerEvents : <span class="keyword">public</span> <a class="code" href="class_d_f_l_1_1_observer_1_1_subject.html">::DFL::Observer::Subject</a>&lt;PeerStatus&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> PeerEvents(std::shared_ptr&lt;Peer&gt; <a class="code" href="group___s31_sdc_common.html#gabaa3f77c47a130ed190865c494540525">peer</a>)</div>
<div class="line">        : m_peer{std::move(<a class="code" href="group___s31_sdc_common.html#gabaa3f77c47a130ed190865c494540525">peer</a>)}</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="class_d_f_l_1_1_observer_1_1_basic_subject.html#a027ceb306b668b2b121a87256458f004">registerObserver</a>(<span class="keyword">const</span> std::weak_ptr&lt;PeerStatus&gt;&amp; peerStatus)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        m_peerStatusObservers.registerObserver(peerStatus);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="class_d_f_l_1_1_observer_1_1_basic_subject.html#a9d1768b033fd7230f6289dd72674f177">unregisterObserver</a>(</div>
<div class="line">        <span class="keyword">const</span> std::weak_ptr&lt;PeerStatus&gt;&amp; peerStatus)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        m_peerStatusObservers.unregisterObserver(peerStatus);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> checkPeerStatus()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (m_peer-&gt;online)</div>
<div class="line">        {</div>
<div class="line">            notifyOnline();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            notifyOffline();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> notifyOnline()</div>
<div class="line">    {</div>
<div class="line">        m_peerStatusObservers.notify(</div>
<div class="line">            [<span class="keyword">this</span>](<span class="keyword">const</span> PeerStatus&amp; status) { status.online(m_peer-&gt;name); });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> notifyOffline()</div>
<div class="line">    {</div>
<div class="line">        m_peerStatusObservers.notify(</div>
<div class="line">            [<span class="keyword">this</span>](<span class="keyword">const</span> PeerStatus&amp; status) { status.offline(m_peer-&gt;name); });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="class_d_f_l_1_1_observer_1_1_basic_subject.html">::DFL::Observer::BasicSubject</a>&lt;</div>
<div class="line">        PeerStatus, <span class="comment">// type of the observers</span></div>
<div class="line">        std::mutex, <span class="comment">// locking policy</span></div>
<div class="line">        <a class="code" href="class_d_f_l_1_1_observer_1_1_invoke_and_catch.html">::DFL::Observer::InvokeAndCatch</a>&lt;</div>
<div class="line">            LogPeerStatusNotificationFailure&gt;&gt; <span class="comment">// invocation policy (log</span></div>
<div class="line">                                               <span class="comment">// exceptions thrown during</span></div>
<div class="line">                                               <span class="comment">// notifications)</span></div>
<div class="line">        m_peerStatusObservers;</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;Peer&gt; m_peer{};</div>
<div class="line">};</div>
<div class="ttc" id="aclass_d_f_l_1_1_observer_1_1_basic_subject_html"><div class="ttname"><a href="class_d_f_l_1_1_observer_1_1_basic_subject.html">DFL::Observer::BasicSubject</a></div><div class="ttdoc">Generic observable container to enable publish-subscribe for smart pointers.</div><div class="ttdef"><b>Definition:</b> BasicSubject.h:81</div></div>
<div class="ttc" id="aclass_d_f_l_1_1_observer_1_1_basic_subject_html_a027ceb306b668b2b121a87256458f004"><div class="ttname"><a href="class_d_f_l_1_1_observer_1_1_basic_subject.html#a027ceb306b668b2b121a87256458f004">DFL::Observer::BasicSubject::registerObserver</a></div><div class="ttdeci">void registerObserver(const std::weak_ptr&lt; ObserverType &gt; &amp;observer) override</div><div class="ttdoc">Register an observer.</div><div class="ttdef"><b>Definition:</b> BasicSubject.h:145</div></div>
<div class="ttc" id="aclass_d_f_l_1_1_observer_1_1_basic_subject_html_a9d1768b033fd7230f6289dd72674f177"><div class="ttname"><a href="class_d_f_l_1_1_observer_1_1_basic_subject.html#a9d1768b033fd7230f6289dd72674f177">DFL::Observer::BasicSubject::unregisterObserver</a></div><div class="ttdeci">void unregisterObserver(const std::weak_ptr&lt; ObserverType &gt; &amp;observer) override</div><div class="ttdoc">Unregister an observer.</div><div class="ttdef"><b>Definition:</b> BasicSubject.h:153</div></div>
<div class="ttc" id="aclass_d_f_l_1_1_observer_1_1_invoke_and_catch_html"><div class="ttname"><a href="class_d_f_l_1_1_observer_1_1_invoke_and_catch.html">DFL::Observer::InvokeAndCatch</a></div><div class="ttdoc">Catching invoke policy for BasicSubject.</div><div class="ttdef"><b>Definition:</b> Invoke.h:27</div></div>
<div class="ttc" id="aclass_d_f_l_1_1_observer_1_1_subject_html"><div class="ttname"><a href="class_d_f_l_1_1_observer_1_1_subject.html">DFL::Observer::Subject</a></div><div class="ttdoc">Interface for generic observable container.</div><div class="ttdef"><b>Definition:</b> Subject.h:19</div></div>
<div class="ttc" id="agroup___s31_sdc_common_html_gabaa3f77c47a130ed190865c494540525"><div class="ttname"><a href="group___s31_sdc_common.html#gabaa3f77c47a130ed190865c494540525">S31::Sdc::Impl::peer</a></div><div class="ttdeci">std::string peer(const struct soap *soap)</div><div class="ttdoc">Helper functions to extract certain information and return them in certain format.</div></div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md294"></a>
Register observers</h3>
<p>After the according instances have been created the observers can be registered. </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> <a class="code" href="group___s31_sdc_common.html#gabaa3f77c47a130ed190865c494540525">peer</a> = std::make_shared&lt;Peer&gt;(<span class="keyword">true</span>, <span class="stringliteral">&quot;Some Peer&quot;</span>);</div>
<div class="line">    PeerEvents peerController{<a class="code" href="group___s31_sdc_common.html#gabaa3f77c47a130ed190865c494540525">peer</a>};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> logPeerStatus = std::make_shared&lt;LogPeerStatus&gt;();</div>
<div class="line">    <span class="keyword">auto</span> throwsOnStatusChange = std::make_shared&lt;ThrowsOnStatusChange&gt;();</div>
<div class="line"> </div>
<div class="line">    peerController.registerObserver(logPeerStatus);</div>
<div class="line">    peerController.registerObserver(throwsOnStatusChange);</div>
</div><!-- fragment --><p> On status changes the the according notification will be invoked. </p><div class="fragment"><div class="line">    peerController.checkPeerStatus();</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md295"></a>
Unregister observers</h3>
<p>An observer can be unregisterd explicitly ... </p><div class="fragment"><div class="line">    peerController.unregisterObserver(logPeerStatus);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group___s31_sdc_common.html#gabaa3f77c47a130ed190865c494540525">peer</a>-&gt;online = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// logPeerStatus no longer gets notified</span></div>
<div class="line">    peerController.checkPeerStatus();</div>
</div><!-- fragment --><p> ... or implicit if the lifetime of a registered observer ends. </p><div class="fragment"><div class="line">    throwsOnStatusChange.reset();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group___s31_sdc_common.html#gabaa3f77c47a130ed190865c494540525">peer</a>-&gt;online = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// throwsOnStatusChange no longer get notified</span></div>
<div class="line">    peerController.checkPeerStatus();</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md296"></a>
Policies</h2>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicLockable</td><td>The given type has to model the named requirement <a href="https://en.cppreference.com/w/cpp/named_req/BasicLockable">BasicLockable</a>, e.g. std::mutex, <a class="el" href="class_d_f_l_1_1_thread_1_1_recursive_mutex.html">DFL::Thread::RecursiveMutex</a>, <a class="el" href="class_d_f_l_1_1_thread_1_1_no_lock.html">DFL::Thread::NoLock</a>.</td></tr>
    <tr><td class="paramname">InvokePolicy</td><td>The invoke policy customizes the behavior when invoking the registered observers. Currently there are <a class="el" href="class_d_f_l_1_1_observer_1_1_invoke_and_catch.html">InvokeAndCatch</a> and <a class="el" href="class_d_f_l_1_1_observer_1_1_invoke.html">Invoke</a> available. This allows to control, e.g. whether an exception from the invoked foreign code breaks notifications or not.</td></tr>
  </table>
  </dd>
</dl>
<p>Here is an example of an invoke policy which logs exceptions during notifications. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>LogPeerStatusNotificationFailure</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> handleException(<span class="keyword">const</span> std::exception&amp; e)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;peer status notification failed with: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                  &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> handleUnknownException()</div>
<div class="line">    {</div>
<div class="line">        std::cout</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;peer status notification failed with an unknown exception\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="class_d_f_l_1_1_observer_1_1_basic_subject.html">::DFL::Observer::BasicSubject</a>&lt;</div>
<div class="line">        PeerStatus, <span class="comment">// type of the observers</span></div>
<div class="line">        std::mutex, <span class="comment">// locking policy</span></div>
<div class="line">        <a class="code" href="class_d_f_l_1_1_observer_1_1_invoke_and_catch.html">::DFL::Observer::InvokeAndCatch</a>&lt;</div>
<div class="line">            LogPeerStatusNotificationFailure&gt;&gt; <span class="comment">// invocation policy (log</span></div>
<div class="line">                                               <span class="comment">// exceptions thrown during</span></div>
<div class="line">                                               <span class="comment">// notifications)</span></div>
<div class="line">        m_peerStatusObservers;</div>
</div><!-- fragment --></div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab8ca2d761d949cc8f90fb03058f3511c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ca2d761d949cc8f90fb03058f3511c">&#9670;&nbsp;</a></span>notify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObserverType , class BasicLockable , class InvokePolicy &gt; </div>
<div class="memtemplate">
template&lt;class Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_d_f_l_1_1_observer_1_1_basic_subject.html">DFL::Observer::BasicSubject</a>&lt; ObserverType, BasicLockable, InvokePolicy &gt;::notify </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a notification to all observers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Since the observer subject does not know the details of the observer interface, the user has to put an appropriate function callback to the method, in which the observable subject passes the observer object as the first parameter. The observable subject will then invoke the callback on every observer.</td></tr>
  </table>
  </dd>
</dl>
<p>See the example. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Framework/Utils/Public/Observer/<a class="el" href="_basic_subject_8h_source.html">BasicSubject.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 13 2023 13:32:11 for Product Core System (PCS) by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
