<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Product Core System (PCS): DFL::NotNull&lt; PtrType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Product Core System (PCS)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_d_f_l.html">DFL</a></li><li class="navelem"><a class="el" href="class_d_f_l_1_1_not_null.html">NotNull</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_d_f_l_1_1_not_null-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DFL::NotNull&lt; PtrType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___s32__group.html">S32</a> &raquo; <a class="el" href="group___utils.html">Utils</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Indicates in a function interface that the passed pointer is assumed to never be null.  
 <a href="class_d_f_l_1_1_not_null.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_not_null_8h_source.html">Framework/Utils/Public/NotNull.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab40870ed46a8473a2d4f8a294e9d1ccd"><td class="memItemLeft" align="right" valign="top"><a id="ab40870ed46a8473a2d4f8a294e9d1ccd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_not_null.html#ab40870ed46a8473a2d4f8a294e9d1ccd">element_type</a> = typename std::pointer_traits&lt; typename std::remove_const&lt; PtrType &gt;::type &gt;::<a class="el" href="class_d_f_l_1_1_not_null.html#ab40870ed46a8473a2d4f8a294e9d1ccd">element_type</a></td></tr>
<tr class="memdesc:ab40870ed46a8473a2d4f8a294e9d1ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type being pointed to. <br /></td></tr>
<tr class="separator:ab40870ed46a8473a2d4f8a294e9d1ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c970f0d2b786c3ff015132d41c2f72"><td class="memItemLeft" align="right" valign="top"><a id="ac8c970f0d2b786c3ff015132d41c2f72"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_not_null.html#ac8c970f0d2b786c3ff015132d41c2f72">pointer</a> = PtrType</td></tr>
<tr class="memdesc:ac8c970f0d2b786c3ff015132d41c2f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type. <br /></td></tr>
<tr class="separator:ac8c970f0d2b786c3ff015132d41c2f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f91d95c2357b7f6a60f8f4e2b2a512"><td class="memItemLeft" align="right" valign="top"><a id="a09f91d95c2357b7f6a60f8f4e2b2a512"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_not_null.html#a09f91d95c2357b7f6a60f8f4e2b2a512">const_pointer</a> = const <a class="el" href="class_d_f_l_1_1_not_null.html#ac8c970f0d2b786c3ff015132d41c2f72">pointer</a></td></tr>
<tr class="memdesc:a09f91d95c2357b7f6a60f8f4e2b2a512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant pointer type. <br /></td></tr>
<tr class="separator:a09f91d95c2357b7f6a60f8f4e2b2a512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adfde363a716c468f47d25c5609a18bdc"><td class="memTemplParams" colspan="2">template&lt;class OtherPtrType &gt; </td></tr>
<tr class="memitem:adfde363a716c468f47d25c5609a18bdc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_not_null.html#adfde363a716c468f47d25c5609a18bdc">NotNull</a> (OtherPtrType other, typename std::enable_if&lt; std::is_convertible&lt; OtherPtrType, PtrType &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:adfde363a716c468f47d25c5609a18bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves given pointer into this class.  <a href="class_d_f_l_1_1_not_null.html#adfde363a716c468f47d25c5609a18bdc">More...</a><br /></td></tr>
<tr class="separator:adfde363a716c468f47d25c5609a18bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb729b7ec81678ffebaef96860e1d970"><td class="memTemplParams" colspan="2">template&lt;class OtherPtrType &gt; </td></tr>
<tr class="memitem:adb729b7ec81678ffebaef96860e1d970"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_not_null.html#adb729b7ec81678ffebaef96860e1d970">NotNull</a> (<a class="el" href="class_d_f_l_1_1_not_null.html">NotNull</a>&lt; OtherPtrType &gt; other, typename std::enable_if&lt; std::is_convertible&lt; OtherPtrType, PtrType &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:adb729b7ec81678ffebaef96860e1d970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction from a not-null with different pointer type.  <a href="class_d_f_l_1_1_not_null.html#adb729b7ec81678ffebaef96860e1d970">More...</a><br /></td></tr>
<tr class="separator:adb729b7ec81678ffebaef96860e1d970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4be66b5289fee07ae920d8eaa56457"><td class="memItemLeft" align="right" valign="top"><a id="a9c4be66b5289fee07ae920d8eaa56457"></a>
<a class="el" href="class_d_f_l_1_1_not_null.html#a09f91d95c2357b7f6a60f8f4e2b2a512">const_pointer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_not_null.html#a9c4be66b5289fee07ae920d8eaa56457">get</a> () const</td></tr>
<tr class="memdesc:a9c4be66b5289fee07ae920d8eaa56457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the held pointer. <br /></td></tr>
<tr class="separator:a9c4be66b5289fee07ae920d8eaa56457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae9fc0e125f76097c4361ee5e0e08a7"><td class="memItemLeft" align="right" valign="top"><a id="acae9fc0e125f76097c4361ee5e0e08a7"></a>
<a class="el" href="class_d_f_l_1_1_not_null.html#ac8c970f0d2b786c3ff015132d41c2f72">pointer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_not_null.html#acae9fc0e125f76097c4361ee5e0e08a7">get</a> ()</td></tr>
<tr class="memdesc:acae9fc0e125f76097c4361ee5e0e08a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the held pointer. <br /></td></tr>
<tr class="separator:acae9fc0e125f76097c4361ee5e0e08a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1a4c46bb70fbee7a378a706a0bfa41"><td class="memItemLeft" align="right" valign="top"><a id="aed1a4c46bb70fbee7a378a706a0bfa41"></a>
<a class="el" href="class_d_f_l_1_1_not_null.html#ab40870ed46a8473a2d4f8a294e9d1ccd">element_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_not_null.html#aed1a4c46bb70fbee7a378a706a0bfa41">operator*</a> () const</td></tr>
<tr class="memdesc:aed1a4c46bb70fbee7a378a706a0bfa41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the element being pointed to. <br /></td></tr>
<tr class="separator:aed1a4c46bb70fbee7a378a706a0bfa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4919c5015bce2ec5298725d0e2174e"><td class="memItemLeft" align="right" valign="top"><a id="a1a4919c5015bce2ec5298725d0e2174e"></a>
<a class="el" href="class_d_f_l_1_1_not_null.html#ab40870ed46a8473a2d4f8a294e9d1ccd">element_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_not_null.html#a1a4919c5015bce2ec5298725d0e2174e">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a1a4919c5015bce2ec5298725d0e2174e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address of the element being pointed to. <br /></td></tr>
<tr class="separator:a1a4919c5015bce2ec5298725d0e2174e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2035088b3f302348ae702333d961c54"><td class="memItemLeft" align="right" valign="top"><a id="af2035088b3f302348ae702333d961c54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NotNull</b> (std::nullptr_t)=delete</td></tr>
<tr class="separator:af2035088b3f302348ae702333d961c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca81953352bd015b0b791267f5435e4b"><td class="memItemLeft" align="right" valign="top"><a id="aca81953352bd015b0b791267f5435e4b"></a>
<a class="el" href="class_d_f_l_1_1_not_null.html">NotNull</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (std::nullptr_t)=delete</td></tr>
<tr class="separator:aca81953352bd015b0b791267f5435e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d4fe605ce9dd7f1c6d15fce3efb820"><td class="memItemLeft" align="right" valign="top"><a id="a45d4fe605ce9dd7f1c6d15fce3efb820"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NotNull</b> (int)=delete</td></tr>
<tr class="separator:a45d4fe605ce9dd7f1c6d15fce3efb820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c892821c6bb71bc9fcd7e2c1cf0295"><td class="memItemLeft" align="right" valign="top"><a id="ac0c892821c6bb71bc9fcd7e2c1cf0295"></a>
<a class="el" href="class_d_f_l_1_1_not_null.html">NotNull</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (int)=delete</td></tr>
<tr class="separator:ac0c892821c6bb71bc9fcd7e2c1cf0295"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae28aa0ee05452fe4aa65e69b4f879ee5"><td class="memItemLeft" align="right" valign="top"><a id="ae28aa0ee05452fe4aa65e69b4f879ee5"></a>
PtrType&#160;</td><td class="memItemRight" valign="bottom"><b>m_ptr</b></td></tr>
<tr class="separator:ae28aa0ee05452fe4aa65e69b4f879ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PtrType&gt;<br />
class DFL::NotNull&lt; PtrType &gt;</h3>

<p>Indicates in a function interface that the passed pointer is assumed to never be null. </p>
<p>This type is directly derived from the cpp-core-guideline <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri-nullptr">Declare a pointer that must not be null as not_null</a>.</p>
<dl class="section user"><dt>Motivation</dt><dd>It's often unclear if a pointer given to a function is allowed to be null. <div class="fragment"><div class="line"><span class="keywordtype">void</span> process(<span class="keywordtype">int</span>* ptr);</div>
</div><!-- fragment -->This leads to either missing null checks or unnecessary null checks which cost performance and clutter the code. The alternative for a not-null-pointer is a reference. But this is not always possible e.g. references cannot be rebound. This file defines an alternative which can be used in cases where references are not suitable. <div class="fragment"><div class="line"><span class="keywordtype">void</span> process(NotNull&lt;int*&gt; ptr);</div>
</div><!-- fragment -->This interface now explicitly states its contract. The given parameter is not allowed to be null and thus is never checked. The client on the other hand gets a compile error if a pointer is passed into the function. <div class="fragment"><div class="line">    <span class="keywordtype">int</span> i = 24;</div>
<div class="line">    <span class="keywordtype">int</span>* j = &amp;i;</div>
<div class="line">    <span class="comment">// shall not compile/link</span></div>
<div class="line">    process(j);</div>
</div><!-- fragment -->This reminds the client to obey the not-null-contract and this contract can be signed like this: <div class="fragment"><div class="line">    <span class="comment">// signing the not-null-contract</span></div>
<div class="line">    <span class="comment">// by ensuring that pointer is not null</span></div>
<div class="line">    <span class="keywordflow">if</span> (j)</div>
<div class="line">    {</div>
<div class="line">        process(<a class="code" href="group___utils.html#gab0f98d10f6c40e56b6c3bee54e27636e">asNotNull</a>(j));</div>
<div class="line">    }</div>
<div class="ttc" id="agroup___utils_html_gab0f98d10f6c40e56b6c3bee54e27636e"><div class="ttname"><a href="group___utils.html#gab0f98d10f6c40e56b6c3bee54e27636e">DFL::asNotNull</a></div><div class="ttdeci">NotNull&lt; Ptr &gt; asNotNull(Ptr p)</div><div class="ttdoc">Encapsulates given pointer in a not-null type.</div><div class="ttdef"><b>Definition:</b> NotNull.h:177</div></div>
</div><!-- fragment -->Of course a client can cheat by passing in a pointer which previously has been assigned to null but assigning null directly does not compile/link. <div class="fragment"><div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// shall not compile</span></div>
<div class="line">        <span class="comment">// NotNull&lt;int*&gt; a(nullptr);</span></div>
<div class="line">        <span class="comment">// NotNull&lt;int*&gt; b(NULL);</span></div>
<div class="line">        <span class="comment">// NotNull&lt;int*&gt; c(0);</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> i = 24;</div>
<div class="line">        <span class="keywordtype">int</span>* j = &amp;i;</div>
<div class="line">        NotNull&lt;int*&gt; <span class="keyword">const</span> a(j);</div>
<div class="line">        <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span>(a);</div>
<div class="line">        <span class="comment">// shall not compile</span></div>
<div class="line">        <span class="comment">// a = nullptr;</span></div>
<div class="line">        <span class="comment">// a = NULL;</span></div>
<div class="line">        <span class="comment">// a = 0;</span></div>
<div class="line">    }</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// shall not compile/link</span></div>
<div class="line">    <span class="comment">// asNotNull(nullptr);</span></div>
<div class="line">    <span class="comment">// asNotNull(NULL);</span></div>
<div class="line">    <span class="comment">// asNotNull(0);</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>No Null-Checks</dt><dd>To be very clear here, the implementation never checks if the held pointer is null. This is not the purpose of this type. Its purpose is state in the interface that the caller is responsible for passing in a not-null pointer.</dd></dl>
<dl class="section user"><dt>Pointer Model</dt><dd>This type itself models a pointer. <div class="fragment"><div class="line">        <span class="keyword">using</span> NotNullSharedPtr = NotNull&lt;boost::shared_ptr&lt;int&gt;&gt;;</div>
<div class="line">        <span class="keyword">const</span> NotNullSharedPtr a(boost::make_shared&lt;int&gt;(24));</div>
<div class="line">        <span class="comment">// making unnecessary-copy to check</span></div>
<div class="line">        <span class="comment">// that copy operations were implemented correctly</span></div>
<div class="line">        <span class="comment">// NOLINTNEXTLINE(performance-unnecessary-copy-initialization)</span></div>
<div class="line">        <span class="keyword">const</span> NotNullSharedPtr b(a);</div>
<div class="line">        ASSERT_EQ(*a, *b);</div>
<div class="line"> </div>
<div class="line">        NotNullSharedPtr c(boost::make_shared&lt;int&gt;(12));</div>
<div class="line">        c = a;</div>
<div class="line">        ASSERT_EQ(*a, *c);</div>
</div><!-- fragment --><div class="fragment"><div class="line">        <span class="comment">// does not compile because unique_ptr</span></div>
<div class="line">        <span class="comment">// is moveonly</span></div>
<div class="line">        <span class="comment">// using NotNullUniquePtr = NotNull&lt;std::unique_ptr&lt;int&gt;&gt;;</span></div>
<div class="line">        <span class="comment">// const NotNullUniquePtr a(std::unique_ptr&lt;int&gt;(new int(24)));</span></div>
<div class="line">        <span class="comment">// const NotNullUniquePtr b(a);</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">        <span class="keyword">using</span> NotNullUniquePtr = NotNull&lt;std::unique_ptr&lt;int&gt;&gt;;</div>
<div class="line">        NotNullUniquePtr a(std::make_unique&lt;int&gt;(24));</div>
<div class="line"> </div>
<div class="line">        NotNullUniquePtr b(std::move(a));</div>
<div class="line">        <span class="comment">// check that a moved from object is null</span></div>
<div class="line">        <span class="comment">// NOLINTNEXTLINE(clang-analyzer-cplusplus.Move,bugprone-use-after-move)</span></div>
<div class="line">        ASSERT_FALSE(a.get());</div>
<div class="line">        ASSERT_EQ(24, *b);</div>
<div class="line"> </div>
<div class="line">        NotNullUniquePtr c(std::make_unique&lt;int&gt;(12));</div>
<div class="line">        c = std::move(b);</div>
<div class="line">        <span class="comment">// check that a moved from object is null</span></div>
<div class="line">        <span class="comment">// NOLINTNEXTLINE(clang-analyzer-cplusplus.Move,bugprone-use-after-move)</span></div>
<div class="line">        ASSERT_FALSE(b.get());</div>
<div class="line">        ASSERT_EQ(24, *c);</div>
<div class="line"> </div>
<div class="line">        std::unique_ptr&lt;int&gt; <span class="keyword">const</span> d = std::move(c.get());</div>
<div class="line">        <span class="comment">// check that a moved from object is null</span></div>
<div class="line">        <span class="comment">// NOLINTNEXTLINE(clang-analyzer-cplusplus.Move,bugprone-use-after-move)</span></div>
<div class="line">        ASSERT_FALSE(c.get());</div>
<div class="line">        ASSERT_EQ(24, *d);</div>
</div><!-- fragment -->This means, although all accessors from this type are const the element type can be changed. <div class="fragment"><div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> NotNull&lt;MyType*&gt; a(j);</div>
<div class="line"> </div>
<div class="line">        a.get()-&gt;val(25);</div>
<div class="line">        ASSERT_EQ(25, a.get()-&gt;val());</div>
<div class="line"> </div>
<div class="line">        a-&gt;val(26);</div>
<div class="line">        ASSERT_EQ(26, a-&gt;val());</div>
<div class="line"> </div>
<div class="line">        (*a).val(27);</div>
<div class="line">        ASSERT_EQ(27, (*a).val());</div>
<div class="line">    }</div>
</div><!-- fragment -->To prohibit modification of the element type declare the not-null-type like this: <div class="fragment"><div class="line">    {</div>
<div class="line">        NotNull&lt;const MyType*&gt; a(j);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// shall not compile</span></div>
<div class="line">        <span class="comment">// because element type is const</span></div>
<div class="line">        <span class="comment">// a.get()-&gt;val(25);</span></div>
<div class="line">        <span class="comment">// a-&gt;val(26);</span></div>
<div class="line">        <span class="comment">// (*a).val(27);</span></div>
<div class="line">        ASSERT_EQ(24, a.get()-&gt;val());</div>
<div class="line">        ASSERT_EQ(24, a-&gt;val());</div>
<div class="line">        ASSERT_EQ(24, (*a).val());</div>
<div class="line">    }</div>
</div><!-- fragment -->This also means that not-null-types shall be passed by value. <div class="fragment"><div class="line"><span class="keywordtype">void</span> process(NotNull&lt;int*&gt; ptr);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Smart or not?</dt><dd>The implementation is heavily inspired by the following libraries. Reading their documentation is helpful too.<ul>
<li><a href="https://github.com/akrzemi1/explicit">explicit</a></li>
<li><a href="https://github.com/Microsoft/GSL">gsl</a></li>
<li><a href="https://dxr.mozilla.org/mozilla-central/source/mfbt/NotNull.h">mozilla-NotNull</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>The major difference is that this implementation in the past also worked for c++03 with the help of boost and that it explicitly allows smart-pointers to be used as pointer types. gsl does not allow this. See <a href="https://github.com/Microsoft/GSL/issues/89">issue</a>.</dd></dl>
<dl class="section user"><dt>Articles</dt><dd><ul>
<li><a href="https://visualstudiomagazine.com/articles/2016/06/01/using-the-not_null-template.aspx">Using the not_null Template for Pointers That Must Never Be Null</a></li>
<li><a href="https://dzone.com/articles/how-not-null-can-improve-your-code">How not_null Can Improve Your Code</a></li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PtrType</td><td>Either a raw (int*) or smart pointer type e.g. std::unique_ptr&lt;int&gt;, std::shared_ptr&lt;int&gt;, ... </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adfde363a716c468f47d25c5609a18bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfde363a716c468f47d25c5609a18bdc">&#9670;&nbsp;</a></span>NotNull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrType &gt; </div>
<div class="memtemplate">
template&lt;class OtherPtrType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_f_l_1_1_not_null.html">DFL::NotNull</a>&lt; PtrType &gt;::<a class="el" href="class_d_f_l_1_1_not_null.html">NotNull</a> </td>
          <td>(</td>
          <td class="paramtype">OtherPtrType&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_convertible&lt; OtherPtrType, PtrType &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves given pointer into this class. </p>
<div class="fragment"><div class="line">        {</div>
<div class="line">            NotNull&lt;std::unique_ptr&lt;int&gt;&gt; <span class="keyword">const</span> a(std::make_unique&lt;int&gt;(24));</div>
<div class="line">            ASSERT_EQ(24, *a);</div>
<div class="line">        }</div>
<div class="line">        {</div>
<div class="line">            std::unique_ptr&lt;int&gt; a(<span class="keyword">new</span> <span class="keywordtype">int</span>(24));</div>
<div class="line">            NotNull&lt;std::shared_ptr&lt;int&gt;&gt; <span class="keyword">const</span> b(std::move(a));</div>
<div class="line">            <span class="comment">// does not compile, because ctor is explicit</span></div>
<div class="line">            <span class="comment">// use style from above</span></div>
<div class="line">            <span class="comment">// NotNull&lt;std::shared_ptr&lt;int&gt;&gt; c = std::move(a);</span></div>
<div class="line">            ASSERT_EQ(24, *b);</div>
<div class="line">        }</div>
<div class="line">        {</div>
<div class="line">            NotNull&lt;std::unique_ptr&lt;int&gt;&gt; a(std::make_unique&lt;int&gt;(24));</div>
<div class="line">            NotNull&lt;std::shared_ptr&lt;int&gt;&gt; <span class="keyword">const</span> b(std::move(a));</div>
<div class="line">            ASSERT_EQ(24, *b);</div>
<div class="line">        }</div>
</div><!-- fragment --><p>The easiest way to construct instances from this class is to use <a class="el" href="group___utils.html#gab0f98d10f6c40e56b6c3bee54e27636e">DFL::asNotNull</a>. </p><div class="fragment"><div class="line">    std::unique_ptr&lt;int&gt; a(std::make_unique&lt;int&gt;(24));</div>
<div class="line">    process(<a class="code" href="group___utils.html#gab0f98d10f6c40e56b6c3bee54e27636e">asNotNull</a>(std::move(a)));</div>
</div><!-- fragment -->
</div>
</div>
<a id="adb729b7ec81678ffebaef96860e1d970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb729b7ec81678ffebaef96860e1d970">&#9670;&nbsp;</a></span>NotNull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrType &gt; </div>
<div class="memtemplate">
template&lt;class OtherPtrType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_f_l_1_1_not_null.html">DFL::NotNull</a>&lt; PtrType &gt;::<a class="el" href="class_d_f_l_1_1_not_null.html">NotNull</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_f_l_1_1_not_null.html">NotNull</a>&lt; OtherPtrType &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_convertible&lt; OtherPtrType, PtrType &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construction from a not-null with different pointer type. </p>
<div class="fragment"><div class="line">        {</div>
<div class="line">            NotNull&lt;std::unique_ptr&lt;int&gt;&gt; <span class="keyword">const</span> a(std::make_unique&lt;int&gt;(24));</div>
<div class="line">            ASSERT_EQ(24, *a);</div>
<div class="line">        }</div>
<div class="line">        {</div>
<div class="line">            std::unique_ptr&lt;int&gt; a(<span class="keyword">new</span> <span class="keywordtype">int</span>(24));</div>
<div class="line">            NotNull&lt;std::shared_ptr&lt;int&gt;&gt; <span class="keyword">const</span> b(std::move(a));</div>
<div class="line">            <span class="comment">// does not compile, because ctor is explicit</span></div>
<div class="line">            <span class="comment">// use style from above</span></div>
<div class="line">            <span class="comment">// NotNull&lt;std::shared_ptr&lt;int&gt;&gt; c = std::move(a);</span></div>
<div class="line">            ASSERT_EQ(24, *b);</div>
<div class="line">        }</div>
<div class="line">        {</div>
<div class="line">            NotNull&lt;std::unique_ptr&lt;int&gt;&gt; a(std::make_unique&lt;int&gt;(24));</div>
<div class="line">            NotNull&lt;std::shared_ptr&lt;int&gt;&gt; <span class="keyword">const</span> b(std::move(a));</div>
<div class="line">            ASSERT_EQ(24, *b);</div>
<div class="line">        }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>S31/S31.Core/src/main/S31/Sdc/Private/Client/SetService/<a class="el" href="_context_states_conversion_8h_source.html">ContextStatesConversion.h</a></li>
<li>Framework/Utils/Public/<a class="el" href="_not_null_8h_source.html">NotNull.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 13 2023 13:32:05 for Product Core System (PCS) by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
