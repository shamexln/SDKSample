<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Product Core System (PCS): DFL::Utils::Test::EqOpFor&lt; ToBeTested &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Product Core System (PCS)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_d_f_l.html">DFL</a></li><li class="navelem"><b>Utils</b></li><li class="navelem"><a class="el" href="namespace_d_f_l_1_1_utils_1_1_test.html">Test</a></li><li class="navelem"><a class="el" href="class_d_f_l_1_1_utils_1_1_test_1_1_eq_op_for.html">EqOpFor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_d_f_l_1_1_utils_1_1_test_1_1_eq_op_for-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DFL::Utils::Test::EqOpFor&lt; ToBeTested &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___s32__group.html">S32</a> &raquo; <a class="el" href="group___utils.html">Utils</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Tests if all members of a type are considered in the implementation of == and != operator.  
 <a href="class_d_f_l_1_1_utils_1_1_test_1_1_eq_op_for.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_eq_op_for_8h_source.html">Framework/Utils/Test/Public/EqOpFor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae44d5b356ca08484b2ac9c84ec6ed5dd"><td class="memTemplParams" colspan="2"><a id="ae44d5b356ca08484b2ac9c84ec6ed5dd"></a>
template&lt;class Tuple &gt; </td></tr>
<tr class="memitem:ae44d5b356ca08484b2ac9c84ec6ed5dd"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_d_f_l_1_1_utils_1_1_test_1_1_eq_op_for.html#ae44d5b356ca08484b2ac9c84ec6ed5dd">with</a> (Tuple ctorParamsOrigin, Tuple ctorParamsPermute) -&gt; ::testing::AssertionResult</td></tr>
<tr class="memdesc:ae44d5b356ca08484b2ac9c84ec6ed5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes two parameter tuples to construct test objects from and returns either an testing::AssertionFailure or testing::AssertionSuccess. <br /></td></tr>
<tr class="separator:ae44d5b356ca08484b2ac9c84ec6ed5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ToBeTested&gt;<br />
class DFL::Utils::Test::EqOpFor&lt; ToBeTested &gt;</h3>

<p>Tests if all members of a type are considered in the implementation of == and != operator. </p>
<p>ToBeTested is the class which == and != operators shall be tested and the tuples given to 'with' are used to construct instances of that type. These instances then are compared using the according operators and if an unexpected result appears an according ::testing::AssertionResult is returned.</p>
<p>This utility assumes that all members which shall be checked in the operators can be injected into the constructor. For example, suppose there is this ctor: </p><div class="fragment"><div class="line">    MoveOnlyType(<span class="keywordtype">int</span> aa,</div>
<div class="line">                 std::string bb,</div>
<div class="line">                 <span class="keywordtype">int</span> cc,</div>
<div class="line">                 <span class="keywordtype">double</span> dd,</div>
<div class="line">                 std::unique_ptr&lt;int&gt; ee = <span class="keyword">nullptr</span>)</div>
<div class="line">        : a{aa}</div>
<div class="line">        , b{std::move(bb)}</div>
<div class="line">        , c{cc}</div>
<div class="line">        , d{dd}</div>
<div class="line">        , e{std::move(ee)}</div>
<div class="line">    {</div>
<div class="line">    }</div>
</div><!-- fragment --><p>To verify that all members are honored in the equality operator one would have to construct an origin instance and then construct N instances where each of them differs in construction by only one parameter. </p><div class="fragment"><div class="line">    <span class="keyword">const</span> MoveOnlyType origin{1, <span class="stringliteral">&quot;2&quot;</span>, 3, 4.0};</div>
<div class="line">    MoveOnlyType moveOnlys[] = {MoveOnlyType{5, <span class="stringliteral">&quot;2&quot;</span>, 3, 4.0},</div>
<div class="line">                                MoveOnlyType{1, <span class="stringliteral">&quot;6&quot;</span>, 3, 4.0},</div>
<div class="line">                                MoveOnlyType{1, <span class="stringliteral">&quot;2&quot;</span>, 7, 4.0},</div>
<div class="line">                                MoveOnlyType{1, <span class="stringliteral">&quot;2&quot;</span>, 3, 8.0}};</div>
</div><!-- fragment --><p>Then one would loop over those instances and compare them against origin. </p><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; mo : moveOnlys)</div>
<div class="line">    {</div>
<div class="line">        ASSERT_FALSE(origin == mo);</div>
<div class="line">        ASSERT_TRUE(origin != mo);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>This is tedious and error prone. Thus with the usage of this utility one just has to write this one-liner. </p><div class="fragment"><div class="line">    ASSERT_TRUE(<a class="code" href="class_d_f_l_1_1_utils_1_1_test_1_1_eq_op_for.html#ae44d5b356ca08484b2ac9c84ec6ed5dd">EqOpFor&lt;MoveOnlyType&gt;::with</a>(</div>
<div class="line">        ctorParamsFor&lt;MoveOnlyType&gt;(1, <span class="stringliteral">&quot;2&quot;</span>, 3, 4.0),</div>
<div class="line">        ctorParamsFor&lt;MoveOnlyType&gt;(5, <span class="stringliteral">&quot;6&quot;</span>, 7, 8.0)));</div>
<div class="ttc" id="aclass_d_f_l_1_1_utils_1_1_test_1_1_eq_op_for_html_ae44d5b356ca08484b2ac9c84ec6ed5dd"><div class="ttname"><a href="class_d_f_l_1_1_utils_1_1_test_1_1_eq_op_for.html#ae44d5b356ca08484b2ac9c84ec6ed5dd">DFL::Utils::Test::EqOpFor::with</a></div><div class="ttdeci">static auto with(Tuple ctorParamsOrigin, Tuple ctorParamsPermute) -&gt; ::testing::AssertionResult</div><div class="ttdoc">Takes two parameter tuples to construct test objects from and returns either an testing::AssertionFai...</div><div class="ttdef"><b>Definition:</b> EqOpFor.h:106</div></div>
</div><!-- fragment --><p>This will construct an origin from the first parameter and use the second one to generate all further instances which will then be compared against the origin instance. One important note though. This utility might also fail if the constructor parameters are configured like this: </p><div class="fragment"><div class="line">    ASSERT_FALSE(<a class="code" href="class_d_f_l_1_1_utils_1_1_test_1_1_eq_op_for.html#ae44d5b356ca08484b2ac9c84ec6ed5dd">EqOpFor&lt;MoveOnlyType&gt;::with</a>(</div>
<div class="line">        ctorParamsFor&lt;MoveOnlyType&gt;(1, <span class="stringliteral">&quot;2&quot;</span>, 3, 4.0),</div>
<div class="line">        ctorParamsFor&lt;MoveOnlyType&gt;(5, <span class="stringliteral">&quot;6&quot;</span>, 3, 8.0)));</div>
</div><!-- fragment --><p>Each value of the second parameter set has to be different from the first one. This is not checked by this function because it would require all parameter types to be equality comparable to compile and in case of reference types (e.g. pointer) this semantic might be even wrong. </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>Framework/Utils/Test/Public/<a class="el" href="_eq_op_for_8h_source.html">EqOpFor.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 13 2023 13:32:12 for Product Core System (PCS) by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
